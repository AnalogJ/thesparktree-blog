<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.thesparktree.com</title>
   
   <link>https://blog.thesparktree.com</link>
   <description>Devops posts & guides about interesting tech like Docker, Letsencrypt, Chef, Angular, Automation, API's or other topics that you should know about. </description>
   <language>en-uk</language>
   <managingEditor> Jason Kulatunga</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>OpenLDAP using STARTTLS & LetsEncrypt</title>
	  <link>/openldap-using-starttls-and-letsencrypt</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2021-06-13T04:19:33-05:00</pubDate>
	  <guid>/openldap-using-starttls-and-letsencrypt</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>LDAP (Lightweight Directory Access Protocol) is an open and cross platform protocol used for directory services authentication.</p>

  <p>LDAP provides the communication language that applications use to
communicate with other directory services servers. Directory services
store the users, passwords, and computer accounts, and share that
information with other entities on the network.</p>

  <p><strong>OpenLDAP</strong> is a <a href="https://en.wikipedia.org/wiki/Free_software">free</a>,
<a href="https://en.wikipedia.org/wiki/Open-source_software" title="Open-source software">open-source</a> implementation of the
<a href="https://en.wikipedia.org/wiki/Lightweight_Directory_Access_Protocol" title="Lightweight Directory Access Protocol">Lightweight Directory Access Protocol</a>
(LDAP) developed by the OpenLDAP Project. It is released under its own BSD-style license called the OpenLDAP Public License.<a href="https://en.wikipedia.org/wiki/OpenLDAP#cite_note-4">[4]</a></p>
</blockquote>

<p>There are 2 commonly used mechanisms to secure LDAP traffic - LDAPS and StartTLS. LDAPS is deprecated in favor of Start TLS [RFC2830].</p>

<p>During some recent infrastructure changes I found out the hard way that <a href="https://issues.jenkins.io/browse/JENKINS-14520">LDAP plugin for Jenkins does not support LDAP over TLS (StartTLS)</a>.
Given that LDAPS is officially deprecated, I began work on a PR to add StartTLS support myself.</p>

<p>Before I could start coding, I needed to create a local development environment with an LDAP server speaking StartTLS.
Unfortunately, this was harder than I anticipated, as StartTLS (while officially supported since LDAPv3) is not well documented.</p>

<p>In the following post ,I’ll show you how to get OpenLDAP up and running with StartTLS, using valid certificates from LetsEncrypt.</p>

<p>As always, the code is Open Source and lives on Github:</p>

<div class="github-widget" data-repo="AnalogJ/docker-openldap-starttls"></div>

<h1 id="self-signed-vs-trusted-ca-certificates">Self-Signed vs Trusted CA Certificates</h1>

<p>There are two types of <strong>SSL Certificates</strong> when you’re talking about signing. There are <strong>Self-Signed SSL Certificates</strong> and certificates
that are signed by a Trusted Certificate Authority (and are usually already trusted by your system).</p>

<p>Most OpenLDAP documentation I was able to find used Self-Signed certifates. While that works fine for most development,
I am trying to replicate a production-like environment, which means real, trusted certificates. Thankfully, we can utilize
short-lived trusted certificates provided by LetsEncrypt to secure our test OpenLDAP server.</p>

<h1 id="generate-letsencrypt-certificate">Generate LetsEncrypt Certificate</h1>

<div class="github-widget" data-repo="matrix-org/docker-dehydrated"></div>

<p>The <a href="https://matrix.org/">matrix.org</a> team provide a simple <a href="https://github.com/matrix-org/docker-dehydrated#behaviour">Docker image</a>
that you can use to generate LetsEncrypt certificates using the DNS-01 challenge. All you need is a custom domain, and a
<a href="https://github.com/AnalogJ/lexicon">DNS provider with an API</a></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>data

<span class="c"># We cannot use a wildcard domain with OpenLDAP, so let's pick a simple obvious subdomain.</span>
<span class="nb">echo</span> <span class="s2">"ldap.example.com"</span> <span class="o">&gt;</span> data/domains.txt

docker run <span class="nt">--rm</span> <span class="se">\</span>
<span class="nt">-v</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/data:/data <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_GENERATE_CONFIG</span><span class="o">=</span><span class="nb">yes</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_CA</span><span class="o">=</span><span class="s2">"https://acme-v02.api.letsencrypt.org/directory"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_CHALLENGE</span><span class="o">=</span><span class="s2">"dns-01"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_KEYSIZE</span><span class="o">=</span><span class="s2">"4096"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_HOOK</span><span class="o">=</span><span class="s2">"/usr/local/bin/lexicon-hook"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_RENEW_DAYS</span><span class="o">=</span><span class="s2">"30"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_KEY_RENEW</span><span class="o">=</span><span class="s2">"yes"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_ACCEPT_TERMS</span><span class="o">=</span><span class="nb">yes</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DEHYDRATED_EMAIL</span><span class="o">=</span><span class="s2">"myemail@gmail.com"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">PROVIDER</span><span class="o">=</span>cloudflare <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">LEXICON_CLOUDFLARE_USERNAME</span><span class="o">=</span><span class="s2">"mycloudflareusername"</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">LEXICON_CLOUDFLARE_TOKEN</span><span class="o">=</span><span class="s2">"mycloudflaretoken"</span> <span class="se">\</span>
docker.io/matrixdotorg/dehydrated
</code></pre></div></div>

<blockquote>
  <p>NOTE: pay attention to those last 3 environmental variables. They are passed to <a href="https://github.com/AnalogJ/lexicon">lexicon</a>
and should be changed to match your DNS provider.</p>
</blockquote>

<p>Once <code class="language-plaintext highlighter-rouge">dehydrated</code> prints its success messge , you should see a handful of new subfolders in <code class="language-plaintext highlighter-rouge">data</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data
├── accounts
│ └── xxxxxxxxxxxxxx
│     ├── account_id.json
│     ├── account_key.pem
│     └── registration_info.json
├── certs
│ └── ldap.example.com
│     ├── cert-xxxxxx.csr
│     ├── cert-xxxxxx.pem
│     ├── cert.csr -&gt; cert-xxxxxx.csr
│     ├── cert.pem -&gt; cert-xxxxxx.pem
│     ├── chain-xxxxxx.pem
│     ├── chain.pem -&gt; chain-xxxxxx.pem
│     ├── combined.pem
│     ├── fullchain-xxxxxx.pem
│     ├── fullchain.pem -&gt; fullchain-xxxxxx.pem
│     ├── privkey-xxxxxx.pem
│     └── privkey.pem -&gt; privkey-xxxxxx.pem
├── chains
├── config
└── domains.txt
</code></pre></div></div>

<p>Let’s leave these files alone for now, and continue to standing up and configuring our OpenLDAP server.</p>

<h1 id="deploying-openldap-via-docker">Deploying OpenLDAP via Docker</h1>

<p>Since we’re not actually deploying a production instance (with HA/monitoring/security hardening/etc) we can take
some short-cuts and use an off-the-shelf Docker image.</p>

<div class="github-widget" data-repo="AnalogJ/docker-openldap-starttls"></div>

<p>The <a href="https://github.com/AnalogJ/docker-openldap-starttls">analogj/docker-openldap-starttls</a> image we’re using in the
example below is based on the  <a href="https://github.com/rroemhild/docker-test-openldap/">rroemhild/test-openldap</a> Docker image,
 which provies a vanilla install of OpenLDAP, and adds Futurama characters as test users.</p>

<p>I’ve customized it to add support for custom Domains, dynamic configuration &amp; the ability to enforce StartTLS on the
serverside (which is great for testing).</p>

<p>Before we start the OpenLDAP container, lets rename and re-organize our LetsEncrypt certificates in a folder structure that the container expects:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p ldap
cp data/fullchain.pem ldap/fullchain.crt
cp data/cert.pem ldap/ldap.crt
cp data/privkey.pem ldap/ldap.key
</code></pre></div></div>

<p>Next, lets start the OpenLDAP Docker container:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run --rm \
-v `pwd`/ldap:/etc/ldap/ssl/ \
-p 10389:10389 \
-p 10636:10636 \
-e LDAP_DOMAIN="example.com" \
-e LDAP_BASEDN="dc=example,dc=com" \
-e LDAP_ORGANISATION="Custom Organization Name, Example Inc." \
-e LDAP_BINDDN="cn=admin,dc=example,dc=com" \
-e LDAP_FORCE_STARTTLS="true" \
ghcr.io/analogj/docker-openldap-starttls:master
</code></pre></div></div>

<blockquote>
  <p>NOTE: the <code class="language-plaintext highlighter-rouge">LDAP_DOMAIN</code> should be your root domain (<code class="language-plaintext highlighter-rouge">example.com</code> vs <code class="language-plaintext highlighter-rouge">ldap.example.com</code> from your certificate).
It’s used for test user email addresses.</p>

  <p>Pay attention to the <code class="language-plaintext highlighter-rouge">LDAP_BASEDN</code> and <code class="language-plaintext highlighter-rouge">LDAP_BINDDN</code> variables, they should match your Domain root as well.</p>

  <p><code class="language-plaintext highlighter-rouge">LDAP_FORCE_STARTTLS=true</code> is optional, you can use it to conditionally start your LDAP server with StartTLS enforced.</p>
</blockquote>

<p>If everything is correct, you should see <code class="language-plaintext highlighter-rouge">slapd starting</code> as your last log message.</p>

<p>Lets test that the container is responding correctly, though the certificate will not match since we’re going to query it
using <code class="language-plaintext highlighter-rouge">localhost:10389</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># LDAPTLS_REQCERT=never tells ldapsearch to skip certificate validation</span>
<span class="c"># -Z is required if we used LDAP_FORCE_STARTTLS="true" to start the container.</span>

<span class="nv">LDAPTLS_REQCERT</span><span class="o">=</span>never ldapsearch <span class="nt">-H</span> ldap://localhost:10389 <span class="nt">-Z</span> <span class="nt">-x</span> <span class="nt">-b</span> <span class="s2">"ou=people,dc=example,dc=com"</span> <span class="nt">-D</span> <span class="s2">"cn=admin,dc=example,dc=com"</span> <span class="nt">-w</span> GoodNewsEveryone <span class="s2">"(objectClass=inetOrgPerson)"</span>

<span class="c"># ...</span>
<span class="c"># search result</span>
<span class="c"># search: 3</span>
<span class="c"># result: 0 Success</span>
<span class="c">#</span>
<span class="c"># numResponses: 8</span>
<span class="c"># numEntries: 7</span>
</code></pre></div></div>

<h1 id="dns">DNS</h1>

<p>Wiring up DNS to correctly resolve to the new container running on you host is left as a exercise for the user.</p>

<p>For testing, I just setup a simple A record pointing <code class="language-plaintext highlighter-rouge">ldap.example.com</code> to my laptop’s private IP address <code class="language-plaintext highlighter-rouge">192.168.0.123</code>.
It obviously won’t resolve correctly outside my home network, but it works fine for testing.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ ping ldap.example.com
PING ldap.example.com (192.168.0.123): 56 data bytes
64 bytes from 192.168.0.123: icmp_seq=0 ttl=64 time=0.045 ms
</code></pre></div></div>

<blockquote>
  <p>NOTE: Remember, DNS updates can take a while to propagate. You’ll want to set a low TTL for the new record if your IP will
be changing constantly (DHCP). You may also need to flush your DNS cache if the changes do not propagate correctly.</p>
</blockquote>

<h1 id="testing">Testing</h1>

<p>You can test that the container is up and running (and accessible via our custom domain) with some handy <code class="language-plaintext highlighter-rouge">ldapsearch</code> commands:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># List all Users (only works with LDAP_FORCE_STARTTLS=false)
ldapsearch -H ldap://ldap.example.com:10389 -x -b "ou=people,dc=example,dc=com" -D "cn=admin,dc=example,dc=com" -w GoodNewsEveryone "(objectClass=inetOrgPerson)"

# Response:
# ldap_bind: Confidentiality required (13)
#	additional info: TLS confidentiality required

# Request StartTLS (works with LDAP_FORCE_STARTTLS=true/false)
ldapsearch -H ldap://ldap.example.com:10389 -Z -x -b "ou=people,dc=example,dc=com" -D "cn=admin,dc=example,dc=com" -w GoodNewsEveryone "(objectClass=inetOrgPerson)"

# Enforce StartTLS (only works with LDAP_FORCE_STARTTLS=true)
ldapsearch -H ldap://example:10389 -ZZ -x -b "ou=people,dc=example,dc=com" -D "cn=admin,dc=example,dc=com" -w GoodNewsEveryone "(objectClass=inetOrgPerson)"

# Query Open LDAP using Localhost url, also works with self-signed certs (-ZZ forces StartTLS)
LDAPTLS_REQCERT=never ldapsearch -H ldap://localhost:10389 -ZZ -x -b "ou=people,dc=example,dc=com" -D "cn=admin,dc=example,dc=com" -w GoodNewsEveryone "(objectClass=inetOrgPerson)"
</code></pre></div></div>

<h1 id="how-does-it-work">How does it work?</h1>

<p>Other than my changes that allow you to customize the domain, there are only 2 main changes from <a href="https://github.com/rroemhild/docker-test-openldap/">rroemhild’s amazing work</a>.</p>

<ul>
  <li>
    <p>A slightly modified <code class="language-plaintext highlighter-rouge">tls.ldif</code> file, which uses the fullchain, private key and certificate provided by LetsEncrypt</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dn: cn=config
changetype: modify
replace: olcTLSCACertificateFile
olcTLSCACertificateFile: /etc/ldap/ssl/fullchain.crt
-
replace: olcTLSCertificateFile
olcTLSCertificateFile: /etc/ldap/ssl/ldap.crt
-
replace: olcTLSCertificateKeyFile
olcTLSCertificateKeyFile: /etc/ldap/ssl/ldap.key
-
replace: olcTLSVerifyClient
olcTLSVerifyClient: never
</code></pre></div>    </div>
  </li>
  <li>
    <p>A new (conditionally loaded) <code class="language-plaintext highlighter-rouge">force-starttls.ldif</code> file, which tells OpenLDAP to force TLS</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dn: cn=config
changetype:  modify
add: olcSecurity
olcSecurity: tls=1

</code></pre></div>    </div>
  </li>
</ul>

<h1 id="fin">Fin</h1>

<div class="github-widget" data-repo="AnalogJ/docker-openldap-starttls"></div>

<p>Getting all the details right took some time, but it was worth it. With this containerized setup, its easy to start
up a fresh “trusted” OpenLDAP image for testing, and conditionally enforce StartTLS.</p>

<p>Thankfully, I was able to use this local containerized OpenLDAP server to finish my work in the
<a href="https://github.com/jenkinsci/ldap-plugin/pull/97">Jenkins LDAP-Plugin</a>, which I’ll be writing about in a future blog post.</p>

	  ]]></description>
	</item>

	<item>
	  <title>Traefik v2 - Advanced Configuration</title>
	  <link>/traefik-advanced-config</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2020-05-28T00:37:09-05:00</pubDate>
	  <guid>/traefik-advanced-config</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>Traefik is the leading open source reverse proxy and load balancer for HTTP and TCP-based applications that is easy,
dynamic, automatic, fast, full-featured, production proven, provides metrics, and integrates with every major cluster technology
      https://containo.us/traefik/</p>
</blockquote>

<p>Still not sure what Traefik is? Basically it’s a load balancer &amp; reverse proxy that integrates with docker/kubernetes to automatically
route requests to your containers, with very little configuration.</p>

<p>The release of Traefik v2, while adding tons of features, also completely threw away backwards compatibility, meaning that
 the documentation and guides you can find on the internet are basically useless.
It doesn’t help that the auto-magic configuration only works for toy examples. To do anything complicated requires some actual configuration.</p>

<p>This guide assumes you’re somewhat familiar with Traefik, and you’re interested in adding some of the advanced features mentioned in the Table of Contents.</p>

<h2 id="requirements">Requirements</h2>

<ul>
  <li>Docker</li>
  <li>A custom domain to assign to Traefik, or a <a href="https://blog.thesparktree.com/local-development-with-wildcard-dns">fake domain (.lan) configured for wildcard local development</a></li>
</ul>

<h2 id="base-traefik-docker-compose">Base Traefik Docker-Compose</h2>

<p>Before we start working with the advanced features of Traefik, lets get a simple example working.
We’ll use this example as the base for any changes necessary to enable an advanced Traefik feature.</p>

<ul>
  <li>
    <p>First, we need to create a shared Docker network. Docker Compose (which we’ll be using in the following examples) will create your container(s)
but it will also create a docker network specifically for containers defined in the compose file. This is fine until
you notice that traefik is unable to route to containers defined in other <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> files, or started manually via <code class="language-plaintext highlighter-rouge">docker run</code>
To solve this, we’ll need to create a shared docker network using <code class="language-plaintext highlighter-rouge">docker network create traefik</code> first.</p>
  </li>
  <li>
    <p>Next, lets create a new folder and a <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file. In the subsequent examples, all differences from this config will be bolded.</p>
  </li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">2'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">traefik</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">traefik:v2.2</span>
    <span class="na">ports</span><span class="pi">:</span>
      <span class="c1"># The HTTP port</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
    <span class="na">volumes</span><span class="pi">:</span>
      <span class="c1"># For Traefik's automated config to work, the docker socket needs to be</span>
      <span class="c1"># mounted. There are some security implications to this.</span>
      <span class="c1"># See https://docs.docker.com/engine/security/security/#docker-daemon-attack-surface</span>
      <span class="c1"># and https://docs.traefik.io/providers/docker/#docker-api-access</span>
      <span class="pi">-</span> <span class="s2">"</span><span class="s">/var/run/docker.sock:/var/run/docker.sock:ro"</span>
    <span class="na">command</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">--providers.docker</span>
      <span class="pi">-</span> <span class="s">--entrypoints.web.address=:80</span>
      <span class="pi">-</span> <span class="s">--providers.docker.network=traefik</span>
    <span class="na">networks</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">traefik</span>

<span class="c1"># Use our previously created `traefik` docker network, so that we can route to</span>
<span class="c1"># containers that are created in external docker-compose files and manually via</span>
<span class="c1"># `docker run`</span>
<span class="na">networks</span><span class="pi">:</span>
  <span class="na">traefik</span><span class="pi">:</span>
    <span class="na">external</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div>

<h2 id="webui-dashboard">WebUI Dashboard</h2>

<p>First, lets start by enabling the built in Traefik dashboard. This dashboard is useful for debugging as we enable other
advanced features, however you’ll want to ensure that it’s disabled in production.</p>

<pre><code class="yaml">
version: '2'
services:
  traefik:
    image: traefik:v2.2
    ports:
      - "80:80"
      <b># The Web UI (enabled by --api.insecure=true)</b>
      <b>- "8080:8080"</b>
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
    command:
      - --providers.docker
      - --entrypoints.web.address=:80
      - --providers.docker.network=traefik
      <b>- --api.insecure=true</b>
    labels:
      <b>- 'traefik.http.routers.traefik.rule=Host(`traefik.example.com`)'</b>
      <b>- 'traefik.http.routers.traefik.service=api@internal'</b>
    networks:
      - traefik
networks:
  traefik:
    external: true
</code></pre>

<p>In a browser, just open up <code class="language-plaintext highlighter-rouge">http://traefik.example.com</code> or the domain name you specified in the <code class="language-plaintext highlighter-rouge">traefik.http.routers.traefik.rule</code> label.
You should see the following dashboard:</p>

<p><img src="https://blog.thesparktree.com/assets/images/traefik/traefik-dashboard.png" alt="traefik dashboard" style="max-height: 500px;" /></p>

<h2 id="automatic-subdomain-routing">Automatic Subdomain Routing</h2>

<p>One of the most useful things about Traefik is its ability to dynamically route traffic to containers.
Rather than have to explicitly assign a domain or subdomain for each container, you can tell Traefik to use the container name
(or service name in a docker-compose file) prepended to a domain name for dynamic routing. eg. <code class="language-plaintext highlighter-rouge">container_name.example.com</code></p>

<pre><code class="yaml">
version: '2'
services:
  traefik:
    image: traefik:v2.2
    ports:
      - "80:80"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
    command:
      - --providers.docker
      - --entrypoints.web.address=:80
      - --providers.docker.network=traefik
      <b>- '--providers.docker.defaultRule=Host(`{{ normalize .Name }}.example.com`)'</b>
    networks:
      - traefik
networks:
  traefik:
    external: true
</code></pre>

<p>Next, lets start up a Docker container running the actual server that we want to route to.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="se">\</span>
    <span class="nt">--rm</span> <span class="se">\</span>
    <span class="nt">--label</span> <span class="s1">'traefik.http.services.foo.loadbalancer.server.port=80'</span> <span class="se">\</span>
    <span class="nt">--name</span> <span class="s1">'foo'</span> <span class="se">\</span>
    <span class="nt">--network</span><span class="o">=</span>traefik <span class="se">\</span>
    containous/whoami

</code></pre></div></div>

<p>Whenever a container starts Traefik will interpolate the <code class="language-plaintext highlighter-rouge">defaultRule</code> and configure a router for this container.
In this example, we’ve specified that the container name is <code class="language-plaintext highlighter-rouge">foo</code>, so the container will be accessible at
<code class="language-plaintext highlighter-rouge">foo.example.com</code></p>

<blockquote>
  <p>Note: if your service is running in another docker-compose file, <code class="language-plaintext highlighter-rouge">{{ normalize .Name }}</code> will be interpolated as: <code class="language-plaintext highlighter-rouge">service_name-folder_name</code>,
so your container will be accessible at <code class="language-plaintext highlighter-rouge">service_name-folder_name.example.com</code></p>
</blockquote>

<h3 id="override-subdomain-routing-using-container-labels">Override Subdomain Routing using Container Labels</h3>

<p>You can override the default routing rule (<code class="language-plaintext highlighter-rouge">providers.docker.defaultRule</code>) for your container by adding a <code class="language-plaintext highlighter-rouge">traefik.http.routers.*.rule</code> label.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="se">\</span>
    <span class="nt">--rm</span> <span class="se">\</span>
    <span class="nt">--label</span> <span class="s1">'traefik.http.services.foo.loadbalancer.server.port=80'</span> <span class="se">\</span>
    <span class="nt">--label</span> <span class="s1">'traefik.http.routers.foo.rule=Host(`bar.example.com`)'</span>
    <span class="nt">--name</span> <span class="s1">'foo'</span> <span class="se">\</span>
    <span class="nt">--network</span><span class="o">=</span>traefik <span class="se">\</span>
    containous/whoami

</code></pre></div></div>

<h2 id="restrict-scope">Restrict Scope</h2>
<p>By default Traefik will watch for all containers running on the Docker daemon, and attempt to automatically configure routes and services for each.
If you’d like a litte more control, you can pass the <code class="language-plaintext highlighter-rouge">--providers.docker.exposedByDefault=false</code> CMD argument to the Traefik container and selectively
enable routing for your containers by adding a <code class="language-plaintext highlighter-rouge">traefik.enable=true</code> label.</p>

<pre><code class="yaml">
version: '2'
services:
  traefik:
    image: traefik:v2.2
    ports:
      - "80:80"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
    command:
      - --providers.docker
      - --entrypoints.web.address=:80
      - --providers.docker.network=traefik
      - '--providers.docker.defaultRule=Host(`{{ normalize .Name }}.example.com`)'
      <b>- '--providers.docker.exposedByDefault=false'</b>
    networks:
      - traefik

  hellosvc:
    image: containous/whoami
    labels:
      <b>- traefik.enable=true</b>
    networks:
      - traefik
networks:
  traefik:
    external: true
</code></pre>

<p>As I mentioned earlier, <code class="language-plaintext highlighter-rouge">normalize .Name</code> will be interpolated as <code class="language-plaintext highlighter-rouge">service_name-folder_name</code> for containers started via docker-compose.
So my Hello-World test container will be accessible as <code class="language-plaintext highlighter-rouge">hellosvc-tmp.example.com</code> on my local machine.</p>

<h2 id="automated-ssl-certificates-using-letsencrypt-dns-integration">Automated SSL Certificates using LetsEncrypt DNS Integration</h2>
<p>Next, lets look at how to securely access Traefik managed containers over SSL using LetsEncrypt certificates.</p>

<p>The great thing about this setup is that Traefik will automatically request and renew the SSL certificate for you, even if your
site is not accessible on the public internet.</p>

<pre><code class="yaml">
version: '2'
services:
  traefik:
    image: traefik:v2.2
    ports:
      - "80:80"
      <b># The HTTPS port</b>
      <b>- "443:443"</b>
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      <b># It's a good practice to persist the Letsencrypt certificates so that they don't change if the Traefik container needs to be restarted.</b>
      <b>- "./letsencrypt:/letsencrypt"</b>
    command:
      - --providers.docker
      - --entrypoints.web.address=:80
      <b>- --entrypoints.websecure.address=:443</b>
      - --providers.docker.network=traefik
      - '--providers.docker.defaultRule=Host(`{{ normalize .Name }}.example.com`)'
      <b># We're going to use the DNS challenge since it allows us to generate</b>
      <b># certificates for intranet/lan sites as well</b>
      <b>- "--certificatesresolvers.mydnschallenge.acme.dnschallenge=true"</b>
      <b># We're using cloudflare for this example, but many DNS providers are</b>
      <b># supported: https://docs.traefik.io/https/acme/#providers </b>
      <b>- "--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=cloudflare"</b>
      <b>- "--certificatesresolvers.mydnschallenge.acme.email=postmaster@example.com"</b>
      <b>- "--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json"</b>
    environment:
      <b># We need to provide credentials to our DNS provider.</b>
      <b># See https://docs.traefik.io/https/acme/#providers </b>
      <b>- "CF_DNS_API_TOKEN=XXXXXXXXX"</b>
      <b>- "CF_ZONE_API_TOKEN=XXXXXXXXXX"</b>
    networks:
      - traefik

  hellosvc:
    image: containous/whoami
    labels:
      <b>- traefik.http.routers.hellosvc.entrypoints=websecure</b>
      <b>- 'traefik.http.routers.hellosvc.tls.certresolver=mydnschallenge'</b>
    networks:
      - traefik
networks:
  traefik:
    external: true
</code></pre>

<p>Now we can visit our Hello World container by visiting <code class="language-plaintext highlighter-rouge">https://hellosvc-tmp.example.com</code>.</p>

<p><img src="https://blog.thesparktree.com/assets/images/traefik/traefik-letsencrypt.jpg" alt="letsencrypt ssl certificate" style="max-height: 500px;" /></p>

<p>Note: Traefik requires additional configuration to automatically redirect HTTP to HTTPS. See the instructions in the next section.</p>

<h3 id="automatically-redirect-http---https">Automatically Redirect HTTP -&gt; HTTPS.</h3>

<pre><code class="yaml">
version: '2'
services:
  traefik:
    image: traefik:v2.2
    ports:
      - "80:80"
      # The HTTPS port
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./letsencrypt:/letsencrypt"
    command:
      - --providers.docker
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      <b>- --entrypoints.web.http.redirections.entryPoint.to=websecure</b>
      <b>- --entrypoints.web.http.redirections.entryPoint.scheme=https</b>
      - --providers.docker.network=traefik
      - '--providers.docker.defaultRule=Host(`{{ normalize .Name }}.example.com`)'
      - "--certificatesresolvers.mydnschallenge.acme.dnschallenge=true"
      - "--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=cloudflare"
      - "--certificatesresolvers.mydnschallenge.acme.email=postmaster@example.com"
      - "--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json"

    environment:
      - "CF_DNS_API_TOKEN=XXXXXXXXX"
      - "CF_ZONE_API_TOKEN=XXXXXXXXXX"
    networks:
      - traefik

  hellosvc:
    image: containous/whoami
    labels:
      - traefik.http.routers.hellosvc.entrypoints=websecure
      - 'traefik.http.routers.hellosvc.tls.certresolver=mydnschallenge'
    networks:
      - traefik
networks:
  traefik:
    external: true
</code></pre>

<p>Note, the <code class="language-plaintext highlighter-rouge">--entrypoints.web.http.redirections.entryPoint.*</code> <code class="language-plaintext highlighter-rouge">command line flags</code> are only available in Traefik v2.2+. If you need HTTP to HTTPS
redirection for Traefik v2.0 or v2.1, you’ll need to add the following <code class="language-plaintext highlighter-rouge">labels</code> instead:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>traefik:
  ....
  labels:
    - traefik.http.routers.https-redirect.entrypoints=web
    - traefik.http.routers.https-redirect.rule=HostRegexp(`{any:.*}`)
    - traefik.http.routers.https-redirect.middlewares=https-only
    - traefik.http.middlewares.https-only.redirectscheme.scheme=https
</code></pre></div></div>

<h2 id="2fa-sso-and-saml">2FA, SSO and SAML</h2>

<p>Traefik supports using an external service to check for credentials. This external service can then be used to enable
single sign on (SSO) for your apps, including 2FA and/or SAML.</p>

<p><img src="https://blog.thesparktree.com/assets/images/traefik/traefik-authforward.png" alt="Traefik external service" style="max-height: 500px;" /></p>

<p>In this example, I’ll be using <a href="https://github.com/authelia/authelia">Authelia</a> to enable SSO, but please note that Authelia does
not support SAML, only 2FA and Forward Auth.</p>

<p>Authelia requires HTTPS, so we’ll base our Traefik configuration on the previous example (Traefik with Letsencrypt certificates &amp; Http to Https redirects)</p>

<pre><code class="yaml">
version: '2'
services:
  traefik:
    image: traefik:v2.2
    ports:
      - "80:80"
      # The HTTPS port
      - "443:443"
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./letsencrypt:/letsencrypt"
    command:
      - --providers.docker
      - --entrypoints.web.address=:80
      - --entrypoints.websecure.address=:443
      - --entrypoints.web.http.redirections.entryPoint.to=websecure
      - --entrypoints.web.http.redirections.entryPoint.scheme=https
      - --providers.docker.network=traefik
      - '--providers.docker.defaultRule=Host(`{{ normalize .Name }}.example.com`)'
      - "--certificatesresolvers.mydnschallenge.acme.dnschallenge=true"
      - "--certificatesresolvers.mydnschallenge.acme.dnschallenge.provider=cloudflare"
      - "--certificatesresolvers.mydnschallenge.acme.email=postmaster@example.com"
      - "--certificatesresolvers.mydnschallenge.acme.storage=/letsencrypt/acme.json"

    environment:
      - "CF_DNS_API_TOKEN=XXXXXXXXX"
      - "CF_ZONE_API_TOKEN=XXXXXXXXXX"
    networks:
      - traefik

  authelia:
    image: authelia/authelia
    volumes:
      - './authelia/configuration.yml:/etc/authelia/configuration.yml:ro'
      - './authelia/users_database.yml:/etc/authelia/users_database.yml:ro'
      - './authelia/data:/etc/authelia/data:rw'
    environment:
      - 'TZ=America/Los_Angeles'
    labels:
      - 'traefik.http.services.authelia.loadbalancer.server.port=9091'
      - 'traefik.http.routers.authelia.rule=Host(`login.example.com`)'
      - 'traefik.http.routers.authelia.entrypoints=websecure'
      - 'traefik.http.routers.authelia.tls.certresolver=mydnschallenge'
    networks:
      - traefik

  hellosvc:
    image: containous/whoami
    labels:
      - traefik.http.routers.hellosvc.entrypoints=websecure
      - 'traefik.http.routers.hellosvc.tls.certresolver=mydnschallenge'
      <b>- 'traefik.http.routers.hellosvc.middlewares=authme'</b>

      <b># this forwardauth.address is complex but incredibly important.</b>
      <b># http://authelia:9091 is the internal routable container name.</b>
      <b># https://login.example.com is the external url for authelia </b>
      <b>- 'traefik.http.middlewares.authme.forwardauth.address=http://authelia:9091/api/verify?rd=https://login.example.com/'</b>
      <b>- 'traefik.http.middlewares.authme.forwardauth.trustforwardheader=true'</b>
      <b>- 'traefik.http.middlewares.authme.forwardauth.authresponseheaders=X-Forwarded-User'</b>
    networks:
      - traefik

networks:
  traefik:
    external: true
</code></pre>

<p>In the above <code class="language-plaintext highlighter-rouge">docker-compose.yml</code> file, under the <code class="language-plaintext highlighter-rouge">authelia</code> service, 2 config files are referenced <code class="language-plaintext highlighter-rouge">configuration.yml</code> and <code class="language-plaintext highlighter-rouge">users_database.yml</code>.</p>

<p><code class="language-plaintext highlighter-rouge">configuration.yml</code> is the configuration file for Authelia. Here’s an example of what that file looks like. You will need ensure that
all references to the <code class="language-plaintext highlighter-rouge">example.com</code> domain are replaced with your chosen (sub)domain.</p>

<p>See <a href="https://github.com/authelia/authelia/blob/master/config.template.yml">config.template.yml on github</a> for a comprehensive list of options.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">###############################################################</span>
<span class="c1">#                   Authelia configuration                    #</span>
<span class="c1">###############################################################</span>

<span class="c1"># The host and port to listen on</span>
<span class="na">host</span><span class="pi">:</span> <span class="s">0.0.0.0</span>
<span class="na">port</span><span class="pi">:</span> <span class="m">9091</span>

<span class="c1"># Level of verbosity for logs: info, debug, trace</span>
<span class="na">log_level</span><span class="pi">:</span> <span class="s">info</span>

<span class="c1"># The secret used to generate JWT tokens when validating user identity by</span>
<span class="c1"># email confirmation.</span>
<span class="na">jwt_secret</span><span class="pi">:</span> <span class="s">change_this_secret</span>

<span class="c1"># Default redirection URL</span>
<span class="c1">#</span>
<span class="c1"># If user tries to authenticate without any referer, Authelia</span>
<span class="c1"># does not know where to redirect the user to at the end of the</span>
<span class="c1"># authentication process.</span>
<span class="c1"># This parameter allows you to specify the default redirection</span>
<span class="c1"># URL Authelia will use in such a case.</span>
<span class="c1">#</span>
<span class="c1"># Note: this parameter is optional. If not provided, user won't</span>
<span class="c1"># be redirected upon successful authentication.</span>
<span class="na">default_redirection_url</span><span class="pi">:</span> <span class="s">http://example.com/</span>

<span class="c1"># TOTP Issuer Name</span>
<span class="c1">#</span>
<span class="c1"># This will be the issuer name displayed in Google Authenticator</span>
<span class="c1"># See: https://github.com/google/google-authenticator/wiki/Key-Uri-Format for more info on issuer names</span>
<span class="na">totp</span><span class="pi">:</span>
  <span class="na">issuer</span><span class="pi">:</span> <span class="s">authelia.com</span>

<span class="c1"># Duo Push API</span>
<span class="c1">#</span>
<span class="c1"># Parameters used to contact the Duo API. Those are generated when you protect an application</span>
<span class="c1"># of type "Partner Auth API" in the management panel.</span>
<span class="c1"># duo_api:</span>
<span class="c1">#   hostname: api-123456789.example.com</span>
<span class="c1">#   integration_key: ABCDEF</span>
<span class="c1">#   secret_key: 1234567890abcdefghifjkl</span>

<span class="c1"># The authentication backend to use for verifying user passwords</span>
<span class="c1"># and retrieve information such as email address and groups</span>
<span class="c1"># users belong to.</span>
<span class="c1">#</span>
<span class="c1"># There are two supported backends: `ldap` and `file`.</span>
<span class="na">authentication_backend</span><span class="pi">:</span>

  <span class="c1"># File backend configuration.</span>
  <span class="c1">#</span>
  <span class="c1"># With this backend, the users database is stored in a file</span>
  <span class="c1"># which is updated when users reset their passwords.</span>
  <span class="c1"># Therefore, this backend is meant to be used in a dev environment</span>
  <span class="c1"># and not in production since it prevents Authelia to be scaled to</span>
  <span class="c1"># more than one instance.</span>
  <span class="c1">#</span>
  <span class="na">file</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/etc/authelia/users_database.yml</span>

<span class="c1"># Access Control</span>
<span class="c1">#</span>
<span class="c1"># Access control is a list of rules defining the authorizations applied for one</span>
<span class="c1"># resource to users or group of users.</span>
<span class="c1">#</span>
<span class="c1"># If 'access_control' is not defined, ACL rules are disabled and the `bypass`</span>
<span class="c1"># rule is applied, i.e., access is allowed to anyone. Otherwise restrictions follow</span>
<span class="c1"># the rules defined.</span>
<span class="c1">#</span>
<span class="c1"># Note: One can use the wildcard * to match any subdomain.</span>
<span class="c1"># It must stand at the beginning of the pattern. (example: *.mydomain.com)</span>
<span class="c1">#</span>
<span class="c1"># Note: You must put patterns containing wildcards between simple quotes for the YAML</span>
<span class="c1"># to be syntactically correct.</span>
<span class="c1">#</span>
<span class="c1"># Definition: A `rule` is an object with the following keys: `domain`, `subject`,</span>
<span class="c1"># `policy` and `resources`.</span>
<span class="c1">#</span>
<span class="c1"># - `domain` defines which domain or set of domains the rule applies to.</span>
<span class="c1">#</span>
<span class="c1"># - `subject` defines the subject to apply authorizations to. This parameter is</span>
<span class="c1">#    optional and matching any user if not provided. If provided, the parameter</span>
<span class="c1">#    represents either a user or a group. It should be of the form 'user:&lt;username&gt;'</span>
<span class="c1">#    or 'group:&lt;groupname&gt;'.</span>
<span class="c1">#</span>
<span class="c1"># - `policy` is the policy to apply to resources. It must be either `bypass`,</span>
<span class="c1">#   `one_factor`, `two_factor` or `deny`.</span>
<span class="c1">#</span>
<span class="c1"># - `resources` is a list of regular expressions that matches a set of resources to</span>
<span class="c1">#    apply the policy to. This parameter is optional and matches any resource if not</span>
<span class="c1">#    provided.</span>
<span class="c1">#</span>
<span class="c1"># Note: the order of the rules is important. The first policy matching</span>
<span class="c1"># (domain, resource, subject) applies.</span>
<span class="na">access_control</span><span class="pi">:</span>
  <span class="c1"># Default policy can either be `bypass`, `one_factor`, `two_factor` or `deny`.</span>
  <span class="c1"># It is the policy applied to any resource if there is no policy to be applied</span>
  <span class="c1"># to the user.</span>
  <span class="na">default_policy</span><span class="pi">:</span> <span class="s">deny</span>

  <span class="na">rules</span><span class="pi">:</span>
    <span class="c1"># Rules applied to everyone</span>

    <span class="pi">-</span> <span class="na">domain</span><span class="pi">:</span> <span class="s2">"</span><span class="s">*.example.com"</span>
      <span class="na">policy</span><span class="pi">:</span> <span class="s">one_factor</span>

<span class="c1"># Configuration of session cookies</span>
<span class="c1">#</span>
<span class="c1"># The session cookies identify the user once logged in.</span>
<span class="na">session</span><span class="pi">:</span>
  <span class="c1"># The name of the session cookie. (default: authelia_session).</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">authelia_session</span>

  <span class="c1"># The secret to encrypt the session cookie.</span>
  <span class="na">secret</span><span class="pi">:</span> <span class="s">change_this_secret</span>

  <span class="c1"># The time in seconds before the cookie expires and session is reset.</span>
  <span class="na">expiration</span><span class="pi">:</span> <span class="m">3600</span> <span class="c1"># 1 hour</span>

  <span class="c1"># The inactivity time in seconds before the session is reset.</span>
  <span class="na">inactivity</span><span class="pi">:</span> <span class="m">300</span> <span class="c1"># 5 minutes</span>

  <span class="c1"># The domain to protect.</span>
  <span class="c1"># Note: the authenticator must also be in that domain. If empty, the cookie</span>
  <span class="c1"># is restricted to the subdomain of the issuer.</span>
  <span class="na">domain</span><span class="pi">:</span> <span class="s">example.com</span>

<span class="c1"># Configuration of the authentication regulation mechanism.</span>
<span class="c1">#</span>
<span class="c1"># This mechanism prevents attackers from brute forcing the first factor.</span>
<span class="c1"># It bans the user if too many attempts are done in a short period of</span>
<span class="c1"># time.</span>
<span class="na">regulation</span><span class="pi">:</span>
  <span class="c1"># The number of failed login attempts before user is banned.</span>
  <span class="c1"># Set it to 0 to disable regulation.</span>
  <span class="na">max_retries</span><span class="pi">:</span> <span class="m">3</span>

  <span class="c1"># The time range during which the user can attempt login before being banned.</span>
  <span class="c1"># The user is banned if the authentication failed `max_retries` times in a `find_time` seconds window.</span>
  <span class="na">find_time</span><span class="pi">:</span> <span class="m">120</span>

  <span class="c1"># The length of time before a banned user can login again.</span>
  <span class="na">ban_time</span><span class="pi">:</span> <span class="m">300</span>

<span class="c1"># Configuration of the storage backend used to store data and secrets.</span>
<span class="c1">#</span>
<span class="c1"># You must use only an available configuration: local, sql</span>
<span class="na">storage</span><span class="pi">:</span>
  <span class="c1"># The directory where the DB files will be saved</span>
  <span class="na">local</span><span class="pi">:</span>
    <span class="na">path</span><span class="pi">:</span> <span class="s">/etc/authelia/data/db.sqlite3</span>

<span class="c1"># Configuration of the notification system.</span>
<span class="c1">#</span>
<span class="c1"># Notifications are sent to users when they require a password reset, a u2f</span>
<span class="c1"># registration or a TOTP registration.</span>
<span class="c1"># Use only an available configuration: filesystem, gmail</span>
<span class="na">notifier</span><span class="pi">:</span>
  <span class="c1"># For testing purpose, notifications can be sent in a file</span>
  <span class="na">filesystem</span><span class="pi">:</span>
    <span class="na">filename</span><span class="pi">:</span> <span class="s">/etc/authelia/data/notification.txt</span>

  <span class="c1"># Sending an email using a Gmail account is as simple as the next section.</span>
  <span class="c1"># You need to create an app password by following: https://support.google.com/accounts/answer/185833?hl=en</span>
  <span class="c1">## smtp:</span>
  <span class="c1">##   username: myaccount@gmail.com</span>
  <span class="c1">##   password: yourapppassword</span>
  <span class="c1">##   sender: admin@example.com</span>
  <span class="c1">##   host: smtp.gmail.com</span>
  <span class="c1">##   port: 587</span>
</code></pre></div></div>

<p>In this example we use a hard coded user database, defined in <code class="language-plaintext highlighter-rouge">users_database.yml</code>. Authelia also supports LDAP integration.</p>

<p>See the <a href="https://docs.authelia.com/configuration/authentication/file.html#password-hash-algorithm-tuning">password-hash-algorithm-tuning</a> documentation for more information.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">users</span><span class="pi">:</span>
  <span class="na">testuser</span><span class="pi">:</span> <span class="c1">## I have set the password below to 'test' for you</span>
    <span class="na">password</span><span class="pi">:</span> <span class="s1">'</span><span class="s">{CRYPT}$6$rounds=500000$Bui4ldW5hXOI9qwJ$IUHQPCusUKpTs/OrfE9UuGb1Giqaa5OZA.mqIpH.Hh8RGFsEBHViCwQDx6DfkGUiF60pqNubFBugfTvCJIDNw1'</span>
    <span class="na">email</span><span class="pi">:</span> <span class="s">your@email.address</span>
    <span class="na">groups</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="s">admins</span>
      <span class="pi">-</span> <span class="s">dev</span>
</code></pre></div></div>

<p>Once you start your docker-compose file and try to access the <code class="language-plaintext highlighter-rouge">hellosvc</code> url, you’ll be redirected automatically to the Authelia login page.</p>

<p><img src="https://blog.thesparktree.com/assets/images/traefik/traefik-authelia.png" alt="Authelia login page" style="max-height: 500px;" /></p>

<h1 id="fin">Fin.</h1>

<p>As you can see, Traefik v2 is pretty powerful, if a bit verbose with its configuration syntax. With its native docker
integration, support for LetsEncrypt and SSO, it’s become a staple of my docker based server environments.</p>


	  ]]></description>
	</item>

	<item>
	  <title>Custom Domains for AWS Lambda/API Gateway using Letsencrypt</title>
	  <link>/custom-domains-for-aws-lambdaapi-gateway-using</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2016-11-08T14:41:19-06:00</pubDate>
	  <guid>/custom-domains-for-aws-lambdaapi-gateway-using</guid>
	  <description><![CDATA[
	     <blockquote>
  <p>AWS Lambda lets you run code without provisioning or managing servers. You pay only for the compute time you consume - there is no charge when your code is not running.</p>
</blockquote>

<p>In general Lambda is well designed and the platform is pretty developer friendly, especially if you use a framework like <a href="https://github.com/serverless/serverless">serverless</a> or <a href="https://github.com/apex/apex">apex</a>. However as someone who creates new services on Lambda all the time, there is one thing that consistently annoys me.</p>

<p><strong>Configuring a custom domain for use with Lambda is stupidly complex for such a common feature.</strong></p>

<p>Here’s the AWS documentation to <a href="https://docs.aws.amazon.com/apigateway/latest/developerguide/how-to-custom-domains.html">use a custom domain with API Gateway</a>. Take a look, I’ll wait.</p>

<p>At first glance the instructions seem somewhat reasonable. For security reasons API Gateway requires SSL for all requests, which means that to use a custom domain, you first need an SSL certificate.</p>

<p>Unfortunately this becomes a problem when you realize that
Letsencrypt HTTP-01 doesn’t work because of the catch-22 requiring you to prove that you own the custom domain before generating certificates. Even worse, AWS’s built-in free certificate service (Certificate Manger) <a href="https://stackoverflow.com/questions/36497896/can-i-use-aws-certificate-manager-certificates-for-api-gateway-with-custom-domai">doesn’t yet support API Gateway</a>.</p>

<p>So what’s the solution?</p>

<hr />

<p>I was able to create a nice little script using python which invokes the <a href="https://aws.amazon.com/cli/">aws-cli</a>, <a href="https://github.com/lukas2511/dehydrated">dehydrated</a> letsencrypt client &amp; <a href="https://github.com/AnalogJ/lexicon">lexicon</a> and does all the steps necessary to add a custom domain to an API Gateway, automatically.</p>

<p>Here’s what it does:</p>

<ul>
  <li>validates that all the correct credentials &amp; environmental variables are set</li>
  <li>validates that the specified AWS API Gateway exists</li>
  <li>generate a new set of letsencrypt certificates for the specified custom domain using the DNS-01 challenge &amp; lexicon</li>
  <li>register custom domain name with AWS (which creates a distribution domain name on cloudfront)</li>
  <li>adds a CNAME dns record mapping your custom domain to the AWS distribution domain</li>
  <li>maps the custom domain to your selected API Gateway</li>
</ul>

<p>The code is all open source and lives here: <a href="https://github.com/AnalogJ/aws-api-gateway-letsencrypt/blob/master/api-gateway-custom-domain.py">Analogj/aws-api-gateway-letsencrypt</a></p>

<div class="github-widget" data-repo="AnalogJ/aws-api-gateway-letsencrypt"></div>

<p>I’ve also created a simple <a href="https://github.com/AnalogJ/aws-api-gateway-letsencrypt/blob/master/Dockerfile">Docker image</a> which you can use if you don’t want to install anything:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">LEXICON_CLOUDFLARE_USERNAME</span><span class="o">=</span><span class="k">***</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">LEXICON_CLOUDFLARE_TOKEN</span><span class="o">=</span><span class="k">***</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">AWS_ACCESS_KEY_ID</span><span class="o">=</span><span class="k">***</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">AWS_SECRET_ACCESS_KEY</span><span class="o">=</span><span class="k">***</span> <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">DOMAIN</span><span class="o">=</span>api.quietthyme.com <span class="se">\</span>
<span class="nt">-e</span> <span class="nv">API_GATEWAY_NAME</span><span class="o">=</span>dev-quietthyme-api <span class="se">\</span>
<span class="nt">-v</span> <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/certs:/srv/certs <span class="se">\</span>
analogj/aws-api-gateway-letsencrypt
</code></pre></div></div>

	  ]]></description>
	</item>

	<item>
	  <title>Generating Intranet and Private Network SSL Certificates using LetsEncrypt</title>
	  <link>/generating-intranet-and-private-network-ssl</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2016-02-09T15:19:33-06:00</pubDate>
	  <guid>/generating-intranet-and-private-network-ssl</guid>
	  <description><![CDATA[
	     <p>This post is a follow up to my previous one <a href="https://blog.thesparktree.com/post/138452017979/automating-ssl-certificates-using-nginx">Automating SSL Certificates using Nginx &amp; LetsEncrypt</a>. This time we’ll be generating SSL certificates for intranet and non-public networks.</p>

<h2 id="requirements">Requirements</h2>
<p>Before we get started, you’ll want to make sure that the following items are true.</p>

<ul>
  <li>You must use a real/purchased domain. <a href="https://en.wikipedia.org/wiki/Top-level_domain#Reserved_domains">Reserved domains/TLD’s</a> like <code class="language-plaintext highlighter-rouge">*.example</code>, <code class="language-plaintext highlighter-rouge">*.test</code>, <code class="language-plaintext highlighter-rouge">*.local</code> will never work.</li>
  <li>You must have an external DNS provider that has an API.
    <ul>
      <li>If your DNS provider doesn’t have an API, you can use <a href="https://www.cloudflare.com">cloud flare.com</a> for free.</li>
    </ul>
  </li>
  <li>You must have python 2.6+ installed</li>
</ul>

<h2 id="install-dehydrated">Install Dehydrated</h2>

<div class="github-widget" data-repo="lukas2511/dehydrated"></div>

<p>The first step is to install a Letsencrypt client. The <a href="https://github.com/letsencrypt/letsencrypt">official client</a> is a bit bloated and complicated to setup. I prefer to use the <a href="https://github.com/lukas2511/dehydrated">dehydrated client</a> instead as its code is easier to understand, has few dependencies and its incredibly simple to automate.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># install dehydrated dependencies (most should already be installed)</span>
apt-get <span class="nb">install</span> <span class="nt">-y</span> openssl curl <span class="nb">sed grep mktemp </span>git

<span class="c"># install dehydrated into /srv/dehydrated</span>
git clone https://github.com/lukas2511/dehydrated.git /srv/dehydrated
</code></pre></div></div>

<h2 id="configure-dehydrated">Configure Dehydrated</h2>
<p>Dehydrated requires some configuration, but not much, the defaults work out of the box. That means that all you need to do is</p>

<ul>
  <li>create a domains.txt file with the url(s) of the site(s) you’re generating ssl certificates for</li>
</ul>

<p>Here’s how we can do that.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># First we need to make the client executable</span>
<span class="nb">chmod</span> +x /srv/dehydrated/dehydrated
<span class="c"># Then we need to specify the intranet/private domain</span>
<span class="nb">echo</span> <span class="s2">"test.intranet.example.com"</span> <span class="o">&gt;</span> /srv/dehydrated/domains.txt
</code></pre></div></div>

<h2 id="install-lexicon">Install Lexicon</h2>

<div class="github-widget" data-repo="AnalogJ/lexicon"></div>

<p>Next we’re going to install the <a href="https://github.com/AnalogJ/lexicon">Lexicon</a> library. Lexicon provides a way to manipulate DNS records on multiple DNS providers in a standardized way.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#  install python requests library dependencies</span>
apt-get <span class="nb">install</span> <span class="nt">-y</span> build-essential python-dev curl libffi-dev libssl-dev
pip <span class="nb">install </span>requests[security]
pip <span class="nb">install </span>dns-lexicon
</code></pre></div></div>

<h2 id="configure-lexicon">Configure Lexicon</h2>
<p>The Lexicon library lets you automatically configure your DNS provider using Letsencrypt DNS challenges without having to deal with creating API calls yourself. Its perfect for generating internal/intranet SSL certs.</p>

<p>Dehydrated requires a hook file to complete <code class="language-plaintext highlighter-rouge">dns-01</code> challenges. The Lexicon repo has an example one that wires up the <code class="language-plaintext highlighter-rouge">deploy_challenge</code> and <code class="language-plaintext highlighter-rouge">clean_challenge</code> calls to Lexicon commands.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl <span class="nt">-O</span> https://raw.githubusercontent.com/AnalogJ/lexicon/master/examples/dehydrated.default.sh /srv/dehydrated
<span class="nb">chmod</span> +x /srv/dehydrated/dehydrated.default.sh
</code></pre></div></div>

<p>The only information that Lexicon requires is:</p>

<ul>
  <li>authentication information such as username/password or token.
    <ul>
      <li>In general your API token should be availble in your DNS provider’s account settings page.</li>
    </ul>
  </li>
  <li>provider name</li>
</ul>

<p>We can pass all that information to Lexicon by setting a handful of environmental variables. If don’t want to do that, you can modify the hook file and add the <code class="language-plaintext highlighter-rouge">--auth-username</code> and <code class="language-plaintext highlighter-rouge">--auth-password</code> parameters to all <code class="language-plaintext highlighter-rouge">lexicon</code> commands.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#If our DNS provider is cloudflare</span>
<span class="nb">export </span><span class="nv">PROVIDER</span><span class="o">=</span>cloudflare
<span class="nb">export </span><span class="nv">LEXICON_CLOUDFLARE_USERNAME</span><span class="o">=</span>username@example.com
<span class="nb">export </span><span class="nv">LEXICON_CLOUDFLARE_TOKEN</span><span class="o">=</span>234dcef90c3d9aa0eb6798e16bdc1e4b
</code></pre></div></div>

<h2 id="generate-certificates">Generate Certificates</h2>
<p>Now that we’ve finished configuring everything, it’s time to generate the certificates. Its as simple as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Lets generate the Letsencrypt SSL certificates</span>
/srv/dehydrated/dehydrated <span class="nt">--cron</span> <span class="nt">--hook</span> /srv/dehydrated/dehydrated.default.sh <span class="nt">--challenge</span> dns-01
</code></pre></div></div>

<p>Our certificates will be available in the following folder:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/srv/dehydrated/certs/
</code></pre></div></div>

<h2 id="fin">Fin</h2>
<p>At this point we have working Letsencrypt SSL certificates for an internal/intranet domain that’s not accessible on the public internet.</p>

<p>I’ve written an example <a href="https://github.com/AnalogJ/lexicon/blob/master/Dockerfile">Dockerfile</a> that you can reference if you’re curious. Just make sure to use <code class="language-plaintext highlighter-rouge">docker run -e "PROVIDER=cloudflare" -e ..</code> to set the environmental variables that you need.</p>

<p>If you’re wondering how to automate this whole process, check out my previous post: <a href="https://blog.thesparktree.com/post/138452017979/automating-ssl-certificates-using-nginx">Automating SSL Certificates using Nginx &amp; LetsEncrypt</a></p>

	  ]]></description>
	</item>

	<item>
	  <title>Automating SSL Certificates using Nginx & Letsencrypt - Without the Catch 22</title>
	  <link>/automating-ssl-certificates-using-nginx</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2016-01-31T23:49:09-06:00</pubDate>
	  <guid>/automating-ssl-certificates-using-nginx</guid>
	  <description><![CDATA[
	     <p>There’s a ton of smart people out there who’ve written guides on <a href="https://sysops.forlaravel.com/letsencrypt">setting</a> <a href="https://blog.rudeotter.com/lets-encrypt-ssl-certificate-nginx-ubuntu/">up</a> <a href="https://davidzych.com/setting-up-ssl-with-lets-encrypt-on-ubuntu-and-nginx/">Nginx</a>, <a href="https://community.letsencrypt.org/t/howto-easy-cert-generation-and-renewal-with-nginx/3491/2">and</a> <a href="https://adambard.com/blog/using-letsencrypt-with-nginx/">automating</a> <a href="https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-14-04">Letsencrypt</a> —but none that setup automation and work 100% correctly out of the box. That’s the goal here, I’ll be documenting all the steps required to get your web application protected by an automatically renewing SSL certificate.</p>

<blockquote>
  <p>NOTE: The following commands will require root user permissions.
You might want to run <code class="language-plaintext highlighter-rouge">sudo su -</code> first.</p>
</blockquote>

<h2 id="installing-nginx">Installing Nginx</h2>

<p>The first step is to install Nginx. If all you want to do is install the standard version, it should be available via your distro’s package manager.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># install Nginx on Ubuntu</span>
apt-get update
apt-get <span class="nb">install</span> <span class="nt">-y</span> nginx
</code></pre></div></div>

<h2 id="install-letsencryptsh">Install Letsencrypt.sh</h2>

<p>The second step is to install a Letsencrypt client. The <a href="https://github.com/letsencrypt/letsencrypt">official client</a> is a bit bloated and complicated to setup. I prefer to use the <a href="https://github.com/lukas2511/letsencrypt.sh">letsencrypt.sh client</a> instead as its code is easier to understand, has few dependencies and its incredibly simple to automate.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># install letsencrypt.sh dependencies (most should already be installed)</span>
apt-get <span class="nb">install</span> <span class="nt">-y</span> openssl curl <span class="nb">sed grep mktemp </span>git

<span class="c"># install letsencrypt.sh into /srv/letsencrypt</span>
git clone https://github.com/lukas2511/letsencrypt.sh.git /srv/letsencrypt
</code></pre></div></div>

<h2 id="configure-letsencrypt">Configure Letsencrypt</h2>

<p>Letsencrypt.sh requires some configuration, but not much, the defaults work out of the box. That means that all you need to do is</p>

<ul>
  <li>create a domains.txt file with the url(s) of the site(s) you’re generating ssl certificates for</li>
  <li>create a acme-challenges folder that can be  accessed by Nginx.</li>
</ul>

<p>Here’s how we can do that.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># First we need to make the client executable</span>
<span class="nb">chmod</span> +x /srv/letsencrypt/letsencrypt.sh
<span class="c"># Then we need to create an ACME challenges folder and symlink it for Nginx to use</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> /srv/letsencrypt/.acme-challenges
<span class="nb">mkdir</span> <span class="nt">-p</span> /var/www/
<span class="nb">ln</span> <span class="nt">-s</span> /srv/letsencrypt/.acme-challenges /var/www/letsencrypt
</code></pre></div></div>

<p>Finally we need to specify the site(s) that will be protected by Letsencrypt ssl certificates.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "www.example.com" &gt;&gt; /srv/letsencrypt/domains.txt
</code></pre></div></div>

<p>Read more about the domains.txt file format <a href="https://github.com/lukas2511/letsencrypt.sh#domainstxt">here</a></p>

<h2 id="configure-nginx-without-the-catch-22">Configure Nginx (without the Catch-22)</h2>

<p>Up to now, the steps I’ve shown have been the same as almost any other Letsencrypt+Nginx guide you’ve seen online. However most of other guides will tell you to configure Nginx in a way that requires manual intervention.</p>

<p>A basic Letsencrypt Nginx configuration file looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># DONT USE THIS, IT WONT WORK.

# /etc/nginx/sites-enabled/example.conf
# HTTP server
server {
	listen      80;
	server_name www.example.com;
	location '/.well-known/acme-challenge' {
		default_type "text/plain";
		alias /var/www/letsencrypt;
	}
	location / {
		return 301 https://$server_name$request_uri;
	}
}
# HTTPS
server {
	listen       443;
	server_name  www.example.com;
	ssl                  on;
	ssl_certificate      /srv/letsencrypt/certs/www.example.com/fullchain.pem;
	ssl_certificate_key  /srv/letsencrypt/certs/www.example.com/privkey.pem;

	...
}
</code></pre></div></div>

<p>There’s a problem with this though. If you try starting up your Nginx server with this config, it’ll throw an error because the SSL certificate files don’t exist. And you can’t start the letencrypt.sh command to generate the SSL certificates without a working Nginx server to serve up the acme-challenge folder. Classic catch 22.</p>

<p>Here’s the solution: we’re going to break up the Nginx configuration into 2 separate configuration files, one for the  HTTP endpoint with letsencrypt challenge files and one for the HTTPS endpoint serving the actual web application.</p>

<p>We’ll then place them both in the <code class="language-plaintext highlighter-rouge">sites-available</code> folder rather than the standard <code class="language-plaintext highlighter-rouge">sites-enabled</code> folder. By default, any configuration files in the <code class="language-plaintext highlighter-rouge">sites-enabled</code> folder are automatically parsed by Nginx when it’s restarted, however we want to control this process.</p>

<p>The HTTP Nginx configuration file will be located at: <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/http.example.conf</code> and look like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># HTTP server
server {
	listen      80;
	server_name www.example.com;
	location '/.well-known/acme-challenge' {
		default_type "text/plain";
		alias /var/www/letsencrypt;
	}
	location / {
		return 301 https://$server_name$request_uri;
	}
}
</code></pre></div></div>

<p>The HTTPS Nginx configuration file will be located at <code class="language-plaintext highlighter-rouge">/etc/nginx/sites-available/https.example.conf</code> and look like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># HTTPS
server {
	listen       443;
	server_name  www.example.com;
	ssl                  on;
	ssl_certificate      /srv/letsencrypt/certs/www.example.com/fullchain.pem;
	ssl_certificate_key  /srv/letsencrypt/certs/www.example.com/privkey.pem;

	#Include actual web application configuration here.
}
</code></pre></div></div>

<h2 id="controlling-nginx">Controlling Nginx</h2>

<p>Before we do anything else, we’ll need to first stop the running Nginx service.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>service nginx stop
</code></pre></div></div>

<p>Then we need to enable the HTTP endpoint by creating a symlink from the <code class="language-plaintext highlighter-rouge">sites-available</code> file to the <code class="language-plaintext highlighter-rouge">sites-enabled</code> folder, and starting the Nginx service</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Enable the http endpoint"</span>
<span class="nb">ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/http.example.conf /etc/nginx/sites-enabled/http.example.conf

<span class="nb">echo</span> <span class="s2">"Starting nginx service..."</span>
service nginx start
</code></pre></div></div>

<p>At this point we have a working HTTP endpoint which will correctly serve up any files in the <code class="language-plaintext highlighter-rouge">acme-challenge</code> folder. Lets generate some certificates.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Generate Letsencrypt SSL certificates"</span>
/srv/letsencrypt/letsencrypt.sh <span class="nt">--cron</span>
</code></pre></div></div>

<p>After the certificates are generated successfully by Letsencrypt.sh, we’ll have to enable our HTTPS endpoint, which is where all standard traffic is being redirected to.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Enable the https endpoint"</span>
<span class="nb">ln</span> <span class="nt">-s</span> /etc/nginx/sites-available/https.example.conf /etc/nginx/sites-enabled/https.example.conf
</code></pre></div></div>

<p>Finally, we need to tell Nginx update its configuration, as we’ve just added the HTTPS endpoint, but we want to do it without any downtime. Thankfully the Nginx developers have provided us a way to do that.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Reload nginx service..."</span>
service nginx reload
</code></pre></div></div>

<p>Now we have a working HTTPS enabled web application. The only thing left to do is automate the certificate renewal.</p>

<h2 id="downtime-free-automatic-certificate-renewal">Downtime-Free Automatic Certificate Renewal</h2>

<p>Automatically renewing your SSL certificate isn’t just a cool feature of Letsencrypt.sh, its actually almost a requirement. By default Letsencrypt certificates expire every 90 days, so renewing it manually would pretty annoying. Thankfully it only takes a single command to completely automate this process.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="s2">"Register Letsencrypt to run weekly"</span>
<span class="nb">echo</span> <span class="s2">"5 8 * * 7 root /srv/letsencrypt/letsencrypt.sh --cron &amp;&amp; service nginx reload"</span> <span class="o">&gt;</span> /etc/cron.d/letsencrypt.sh
<span class="nb">chmod </span>u+x  /etc/cron.d/letsencrypt.sh
</code></pre></div></div>

<p>That command will register a new cron task to run every week that will run the letsencrypt.sh command. If the letsencrypt.sh script detects that the certificate will expire within 30 days, the certificates will be renewed automatically, and the Nginx server will reload, without any downtime.</p>

<h2 id="fin">Fin</h2>

<p>At this point you should have a working SSL protected web application, with automatic certificate renewal, at the cost of a handful of bash commands.</p>

<p>If you’re looking for an example of how this process can be used to automatically protect a website running inside a Docker container, look no further than my minimal <a href="https://github.com/AnalogJ/letsencrypt-http01-docker-nginx-example">letsencrypt-http01-docker-nginx-example</a> repo.</p>

<div class="github-widget" data-repo="AnalogJ/letsencrypt-http01-docker-nginx-example"></div>

<p>If you would like to see a more real world use of Letsencrypt with Nginx and automation you should check my <a href="https://github.com/AnalogJ/gitmask">Gitmask</a> repo.</p>

	  ]]></description>
	</item>


</channel>
</rss>
