<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.thesparktree.com</title>
   
   <link>https://blog.thesparktree.com</link>
   <description>Devops posts & guides about interesting tech like Docker, Letsencrypt, Chef, Angular, Automation, API's or other topics that you should know about. </description>
   <language>en-uk</language>
   <managingEditor> Jason Kulatunga</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>API Design Best Practices - Part 2</title>
	  <link>/api-design-best-practices-part-2</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2014-03-20T12:01:00-05:00</pubDate>
	  <guid>/api-design-best-practices-part-2</guid>
	  <description><![CDATA[
	     <p>This is a follow up to my previous API design post <a href="http://blog.thesparktree.com/post/41988581166/api-design-best-practices">“API Design Best Practices”</a></p>

<h1 id="use-the-new-hotness">Use the new hotness</h1>

<p>Use the newest standards whenever possible, rather than an older standard that you’re more comfortable with. In general older standards have fewer maintained libraries, making it harder for developers to start integrating with your API. Standards change over time for a variety of reasons, be it security or feature set. Unless you have a specific use case for using an old standard, choose the newest one.
The official OAuth ruby gem is a good example of the pain developers go though trying to find maintained libraries for old standards. The official OAuth link for the ruby gem is the github repo: <code class="language-plaintext highlighter-rouge">pelle/oauth</code> which informs you to go to the newer version on <code class="language-plaintext highlighter-rouge">mojodna/oauth</code> which then tells you to visit <code class="language-plaintext highlighter-rouge">oauth/oauth-ruby</code> which does not exist. The correct library is <code class="language-plaintext highlighter-rouge">oauth-xx/oauth-ruby</code>, last updated 2 years ago,</p>

<h1 id="dont-be-bleeding-edge">Don’t be bleeding edge</h1>

<p>Remember, draft specifications expire. If your going to use a spec that has still not been ratified, make sure you keep it up to date, even once you finish your API.  As the specification is finalized, developers attempting to use popular libraries will run into uncommon and hard to debug issues with your no-longer-standard API. Highrise designed their API to support OAuth2 when it was still in the process of being ratified, creating an API supporting <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-07">draft version 2.07</a>. They use an option <code class="language-plaintext highlighter-rouge">web_server</code> that has since been removed in the finalized specification, almost 24 releases later.</p>

<h1 id="xml-is-evil">XML is evil</h1>

<p>That headline is more link-bait than anything, but there is a reason that you see fewer and fewer XML based API’s. Partially because JSON is the new hotness (with the community support that entails), but also because XML is verbose, heavier and harder to code. JSON was designed from the ground up to serialize data structures, while XML was designed to give semantic definition to text in documents.</p>

<p>It’s easy to understand how the following JSON structure maps to a data structure</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
	</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Jason Kulatunga"</span><span class="p">,</span><span class="w">
	</span><span class="nl">"email"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Jason@TheSparkTree.com"</span><span class="p">,</span><span class="w">
	</span><span class="nl">"website"</span><span class="p">:</span><span class="w"> </span><span class="s2">"http://www.thesparktree.com"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>However it’s XML equivalent can be written in many different ways.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;person&gt;&lt;name&gt;</span>Jason Kulatunga<span class="nt">&lt;/name&gt;&lt;email&gt;</span>Jason@TheSparkTree.com<span class="nt">&lt;/email&gt;&lt;website&gt;</span>http://www.thesparktree.com<span class="nt">&lt;/website&gt;&lt;/person&gt;</span>
</code></pre></div></div>

<p>or</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;person</span> <span class="na">name=</span><span class="s">"Jason Kulatunga"</span> <span class="na">email=</span><span class="s">"Jason@TheSparkTree.com"</span> <span class="na">website=</span><span class="s">"http://www.thesparktree.com"</span><span class="nt">&gt;&lt;/person&gt;</span>
</code></pre></div></div>

<p>This makes it just that much harder to generate XML requests, or parse XML responses into data structures. The <a href="http://developers.freshbooks.com/docs/invoices/">Freshbooks Invoices API</a> provides a example of why requests formats are standardized to <code class="language-plaintext highlighter-rouge">application/json</code> or <code class="language-plaintext highlighter-rouge">applicaton/www-form-encoded</code>.</p>

<h1 id="responses-shouldnt-lie">Responses shouldn’t lie</h1>

<p>If you’re implementing a specification that has a standardized response format, please don’t decide to send a response with a different encoding. Sending a correct <code class="language-plaintext highlighter-rouge">Content-Type</code> header is not enough, a deviation means you are no longer complaint with the specification.
Facebook is guilty of this. The OAuth2 specification states that upon successful OAuth authentication:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The parameters are included in the entity-body of the HTTP response using the "application/json" media type
</code></pre></div></div>

<p>However they decided to ignore this, and instead return a <code class="language-plaintext highlighter-rouge">www-form-encoded</code> response, meaning that most standard OAuth2 libraries will be unable to parse the access token correctly.</p>

<h1 id="never-design-your-own-serialization-format">Never design your own serialization format</h1>

<p>You should never see the following in the documentation as a sample response for any API.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#Wed Feb 29 03:07:33 PST 2012
AUTHTOKEN=bad18eba1ff45jk7858b8ae88a77fa30
RESULT=TRUE
</code></pre></div></div>

<p>The above is an example of <a href="http://www.zoho.com/crm/help/api/using-authentication-token.html">ZOHO</a>’s serialization format for passing back tokens after successful authentication. It’s confusing, follows no encoding standards (even the date is a custom format) and mixes the way data is structured (the expiry timestamp is a comment??).
Response formats are standardized, do not make your own, even XML is better than this. This should never have happened.</p>

<h1 id="soap-is-dead">SOAP is dead</h1>

<p>Like XML, SOAP API’s are talked about with disdain for a reason. Please don’t use SOAP if you’re building a new API -I’m looking at you Paypal.</p>

<h1 id="support-untrusted-third-parties">Support untrusted third-parties</h1>

<p>ZOHO is my punching bag again for this example, but I’ve seen many SAAS’s do the same thing. Here’s the scenario: you want to access an API on behalf of a user, but to access the endpoints you need an API key. So far so good. Now to generate the API key, you need the user’s username and password which you send to a special API, that returns an API key. Wait what? First of all you’re forcing your users to give their usernames and passwords to third parties just so the third party can access their data. As an API designer your also limiting your control and knowledge over how your API is being used as you can no longer track popular/abusive applications. Never make the developer request the user’s username and password to generate an API key, it makes the OAuth process completely redundant.</p>

<h1 id="per-application-rate-limits-are-evil">Per Application rate limits are evil</h1>

<p>We as developers understand that you need to place limits on our applications so we do not abuse your system, but sane request limits are preferred. API requests/user/day{other time period} are preferred rather than a API request limit per application. Per application rate limits only abuse your most successful developers. Per user rate limits allow our applications to grow at a reasonable rate. The Twitter API fiasco is a good example of how per application rate limits can hurt your most devoted developers.</p>

<h1 id="provide-developer-test-data-accounts">Provide developer test data accounts.</h1>

<p>You have a paid product, something that your clients use, love and are willing to pay for monthly. You also have an API, and you want to make it easy for developers to integrate with your ecosystem and provide additional value for using your service. If these statements are true, please do not expect us to build a meaningful application within your trial period. We are users too, and we hate having to create throw away accounts for development. Provide us with permanent test accounts, preferably ones that are filled out with reasonable test data.</p>

<h1 id="scope-permissions">Scope permissions</h1>

<p>Creating an application with granular security is hard and complicated, but scaring the user into thinking that we will have access to view and change their private data on your service when all we want to do is read their name and email address is a huge blow to trustworthiness. Please build support for granular permissions if it makes sense.</p>

<h1 id="offline-application-access">Offline Application Access</h1>

<p>Inline with the previous point about Scope, you want to protect your users from shady Developers, so you decide that your API access tokens are going to expire after 30 minutes…Here’s looking at you XERO. Please don’t do that, provide us with a offline access scope and a refresh token, make it obvious to the user that we will be accessing their data even when they are not logged in, and show them that they can remove access to our application at anytime.</p>

<p>#Please don’t mix and match API authentication/validation schemes.</p>

<p>Paymill makes third party developers use OAuth2 to authenticate as a user, after which point we have to use the newly requested accesstoken as a username with basic authentication..wat?</p>

<h1 id="custom-url-endpoints-per-customer">Custom url endpoints per customer</h1>

<p>So you’re a company that wants to provide your users with branded url. Something like: <code class="language-plaintext highlighter-rouge">myawesomecompany.lessaccounting.com</code> or <code class="language-plaintext highlighter-rouge">beeniebabysrus.uservoice.com</code>. Even if that’s the way that the users can access their data, please do not force us as developers to visit <code class="language-plaintext highlighter-rouge">myawesomecompany.lessaccounting.com/oauth/authenticate</code> to start your OAuth flow. It just means that I’m forced to ask the user what their company url is before they can even login. Once they login, you will have their domain anyways, and you can associate it with their accesstoken.</p>

<h1 id="consistent-names-in-documentation">Consistent names in documentation</h1>

<p>Please use the standard nomenclature for OAuth if you are using it: <code class="language-plaintext highlighter-rouge">client_id</code>, <code class="language-plaintext highlighter-rouge">customer key</code>, <code class="language-plaintext highlighter-rouge">client_secret</code>, <code class="language-plaintext highlighter-rouge">consumer secret</code>. Don’t use <code class="language-plaintext highlighter-rouge">APIkey</code>, <code class="language-plaintext highlighter-rouge">api token key</code>, <code class="language-plaintext highlighter-rouge">api secret key</code>, <code class="language-plaintext highlighter-rouge">api key secret</code>, <code class="language-plaintext highlighter-rouge">some other made-up name here</code>. We’re developers, we understand technical documentation and we prefer nomenclature that matches the variables and parameters that we have been using on every other site that talks about OAuth. Please don’t confuse us with your own naming structures.</p>

<h1 id="consistent-documentation">Consistent documentation</h1>

<p>Keep your documentation consistent. If you have a product, that you call Paymill Connect, and then later on you create a new product called Paymill Unite that incorporates the features of Connect and extends them, please remove your outdated documentation, or make it obvious that it has been superseded by Unite. Also if you’re going to show one of the token endpoints on a “Getting Started” page, show the other one too. It’s frustrating when people stop in the middle without</p>

<h1 id="documentation-is-king">Documentation is King</h1>

<p>The number of developers that integrate their application with your service is directly proportional to the difficulty in finding and understanding your documentation. Anyone who’s ever attempted to understand the Paypal Classic API using their documentation site will understand what I mean.</p>

<p>Salesforce is an example of a large, correctly documented API. Stripe’s level of documentation should be the goal for most small to medium size API’s.</p>

<p><a href="http://www.salesforce.com/us/developer/docs/api_rest/">http://www.salesforce.com/us/developer/docs/api_rest/</a></p>

<h1 id="show-total-counts-when-paginating-results">Show total counts when paginating results</h1>
<p>Stripe has a great API, but even they could make a few small changes that would make the lives of developers easier. If you are paginating responses, please provide us with a total count, instead of just a response count. I’m not saying this would be as easy as it sounds, as I understand that depending on your database you may have to do a full count query to get this number. Its just a nice to have as a developer.</p>

<h1 id="encoding-body-parameters">Encoding Body parameters</h1>

<p>URL encoding body individual body parameters…. why would you do this? And if you are going to do it, be consistent. Encode the whole body not parts of it. <a href="https://gist.github.com/IntuitDeveloperRelations/6024616#file-v2-qbo-item-filter-v2sdk-devdefined-cs-L19">https://gist.github.com/IntuitDeveloperRelations/6024616#file-v2-qbo-item-filter-v2sdk-devdefined-cs-L19</a></p>

<h1 id="hashing-algorithms">Hashing algorithms</h1>

<p>If you are going to use a hash of the parameters as a signature in your API, make sure you also explicitly state how the hash is generated, the algorithm and the order of the parameters. Distimo is at fault here.</p>

<h1 id="provide-a-rest-api">Provide a REST API</h1>

<p>Braintree doesn’t have a public REST API, instead they just provide gems and libraries in various languages for integration. While giving them kudos for wrapping their API in over 8 different languages, sometimes its nice to have direct access to an API for testing with Postman, Fiddler, curl, etc.</p>

	  ]]></description>
	</item>

	<item>
	  <title>API Design Best Practices</title>
	  <link>/api-design-best-practices</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2013-03-25T02:00:00-05:00</pubDate>
	  <guid>/api-design-best-practices</guid>
	  <description><![CDATA[
	     <p>Or how to stop third party developers from hating you.</p>

<p>As web developers most of us are accustomed to using APIs. Most of the time all we do is use libraries that abstract away the pain of working with someone elses code, and let us build our products on top.</p>

<p>While working on our cloud ebook manager <a href="http://www.quietthyme.com">QuietThyme</a>, we recognized that integrating GoodReads bookshelves, reviews and comments with our users library would be a very useful feature. We immediately began delving into the GoodReads documentation to check if they had a C# library available for us to use. Unfortunately they didn’t and we began the process of creating our own open source implementation.</p>

<p>This post is a summary of some of the pain points that we experienced while implementing a client for the GoodReads API. These issues are definitely not unique to GoodReads, many of the most popular APIs out there have similar issues. I decided to create this post to show API designers that they are creating a <code class="language-plaintext highlighter-rouge">contract</code> between themselves and their developers. By following the guidelines below they can insure that the process of implementing their API is as simple as possible.</p>

<h1 id="1-every-api-should-return-a-consistent-wrapper-object">1. Every API should return a consistent wrapper object</h1>

<p>Developers need to know the status of every API response. API designers need to choose a consistent way of returning state information, either by always returning the status via the HTTP headers or, the more preferred way, by creating a wrapper that includes status information as well as the API return data.</p>

<p>GoodReads seems to do this by returning a Request tag inside most API responses:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;goodreadsresponse&gt;&lt;request&gt;&lt;authentication&gt;</span>true<span class="nt">&lt;/authentication&gt;&lt;key&gt;&lt;/key&gt;&lt;method&gt;&lt;/method&gt;&lt;/request&gt;</span>
  **API RESPONSE DATA HERE**
<span class="nt">&lt;goodreadsresponse&gt;</span>
</code></pre></div></div>

<p>However it soon becomes apparent that when an error occurs they instead just return:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;error&gt;book not found&lt;/error&gt;
</code></pre></div></div>

<p>or :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invalid Request
</code></pre></div></div>

<p>or even an empty xml document, which throws the following error in most XML parsers:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>This page contains the following errors:
error on line 1 at column 1: Document is empty
</code></pre></div></div>

<p>This is not acceptable. By mixing response xml data structures, you force developers to write multiple response handlers, and then run them all until a ‘valid’ response is found. Its even worse when plain text is returned when XML is assumed.</p>

<p>Instead if they had returned something like this:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;goodreadsresponse&gt;&lt;request&gt;&lt;authentication&gt;</span>true<span class="nt">&lt;/authentication&gt;&lt;key&gt;&lt;/key&gt;&lt;method&gt;&lt;/method&gt;&lt;errorcode&gt;</span>4321<span class="nt">&lt;/errorcode&gt;&lt;error&gt;</span>book not found<span class="nt">&lt;/error&gt;&lt;/request&gt;</span>
  **API RESPONSE DATA HERE**
<span class="nt">&lt;goodreadsresponse&gt;</span>
</code></pre></div></div>

<p>The developer would only have to check if the errorcode field has a value, or is greater than 0, and if so display the error message, otherwise the response is known to be correct and only <strong>one</strong> response handler is required. The integration is much more stable and testable.</p>

<h1 id="2-support-multiple-formats-or-dont">2. Support multiple formats, or don’t</h1>

<p>Every developer has a preference for output formats, some love JSON, some love XML. API designers understand that, and for the most part they leverage the serialization support built into most modern frameworks to output both formats. However as developers we understand that for each output format you decide to support, time will need to be taken to test and ensure all your data is serialized properly. We even understand if most of your APIs support both, but a few only support one or the other. However please <strong>do not</strong> decide to mix it up and have some your API support one format, some the other, and some both. It’s inconsistent and painful to implement. Every deserialization implementation has its own quirks, which takes time.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>URL: http://www.goodreads.com/book/title?format=FORMAT
HTTP method: GET
Parameters:
format: xml or json
..

URL: http://www.goodreads.com/author/list.xml
HTTP method: GET
Parameters:
key: Developer key (required).
..

URL: http://www.goodreads.com/book/review_counts.json
HTTP method: GET
Parameters:
format: json
..
</code></pre></div></div>

<p>If you can’t support the same formats on all methods of your API, please pick at least one format and make sure it can be returned by all API calls.</p>

<h1 id="3-support-api-versioning">3. Support API versioning</h1>

<p>Again, it’s about consistency in your API. It gives you, the API designer the freedom to deprecate methods in newer versions of your API while still giving developers using your old API time to restructure their code.</p>

<p>Somewhat related to versioning is an issue I noticed with the following GoodReads API:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get the Goodreads book ID given an ISBN. Response contains the ID without any markup.
URL: http://www.goodreads.com/book/isbn_to_id
HTTP method: GET
Parameters:
key: Developer key (required).
isbn: The ISBN of the book to lookup.
</code></pre></div></div>

<p>When called upon by my C# library, the GoodReads api will instead return the result for:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get the reviews for a book given an ISBN
Get an xml or json file that contains embed code for the iframe reviews widget that shows excerpts (first 300 characters) of the most popular reviews of a book for a given ISBN. The reviews are from all known editions of the book.
URL: http://www.goodreads.com/book/isbn?format=FORMAT&amp;amp;isbn=ISBN
</code></pre></div></div>

<p>I can only assume that either GoodReads has deprecated the <code class="language-plaintext highlighter-rouge">isbn_to_id</code> API without any notice, or they have some sort of API routing error such that isbn_to_id == isbn</p>

<h1 id="4-keep-your-response-key-types-consistent">4. Keep your response key types consistent.</h1>
<p>When returning unique identifiers such a book ids or comment ids, tweet ids or anything else, it helps if the key type is consistent across different API calls.</p>

<p>If your book id is an integer then this response if fine from one api:</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;bookid</span> <span class="na">type=</span><span class="s">"integer"</span><span class="nt">&gt;</span>1001<span class="nt">&lt;/bookid&gt;</span>
</code></pre></div></div>

<p>or even this from another:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;bookid&gt;1001&lt;/bookid&gt;
</code></pre></div></div>

<p>But please, never have another API return this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;bookid type="string"&gt;1001&lt;/bookid&gt;
</code></pre></div></div>

<h1 id="5a-keep-your-api-parameter-handling-consistent">5a. Keep your API parameter handling consistent.</h1>
<p>If you have multiple related APIs that all take in the same parameter, such as <code class="language-plaintext highlighter-rouge">name</code>, for different CRUD operations, ensure that the parameter is handled the same way across the group.</p>

<p>For example, if your <code class="language-plaintext highlighter-rouge">name</code> parameter is case-insensitive for the Create, Update and Delete APIs, make sure it is also case insensitive for the Read API. We noticed that the GoodReads <code class="language-plaintext highlighter-rouge">Edit book shelf</code> and <code class="language-plaintext highlighter-rouge">Get the books on a members shelf</code> API calls both took a bookshelf name as a parameter, but when requesting the <code class="language-plaintext highlighter-rouge">Get the books on a members shelf</code> API, the bookshelf name is case sensitive, even though the <code class="language-plaintext highlighter-rouge">Edit book shelf</code> and other bookshelf related calls are case insensitive.</p>

<h1 id="5b-keep-your-api-parameter-count-consistent">5b. Keep your API parameter count consistent.</h1>
<p>If we see this in your developer documentation, something has gone horribly wrong:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Get the reviews for a book given an ISBN
Get an xml or json file that contains embed code for the iframe reviews widget that shows excerpts (first 300 characters) of the most popular reviews of a book for a given ISBN. The reviews are from all known editions of the book.
URL: http://www.goodreads.com/book/isbn?format=FORMAT&amp;amp;isbn=ISBN
HTTP method: GET
Parameters:
format: xml or json
callback: function to wrap JSON response if format=json
**key: Developer key (required only for XML).**
**user_id: 8488829 (required only for JSON)**
...
</code></pre></div></div>
<p>The number of parameters to use your api should be the same if its JSON or XML, the only exception being if your output is JSONP and you need a callback parameter.</p>

<h1 id="6-the-api-url-matters">6. The API url matters.</h1>
<p>Its only a minor issue, but it does make a difference. Structure your API into logical groups if possible. It helps us break up our API client along the same lines. As well, having a consistent base url makes it just a little bit easier to use your API. Something along the lines of:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://www.MyAwesomeSAAS.com/api/{Group}/{Action}
</code></pre></div></div>

<p>is just a bit nicer to work with than:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http://www.goodreads.com/user_shelves.xml
http://www.goodreads.com/list/book.xml?id=BOOK_ID
http://www.goodreads.com/api/auth_user
http://www.goodreads.com/api/author_url/&lt;id&gt;
</code></pre></div></div>

<h1 id="7-use-oauth">7. Use OAuth</h1>
<p>Or atleast some sort of API authentication. Yes it is a bit of an investment, yes you will need to spend time and money implementing it and yes, it might break YAGNI. The problem is that if you’re going to build an API, you want developers using it, you want it to become popular. And if you wait until your API does become popular to implement OAUTH, you are creating a significant breaking change that’s going to force all the developers using your API to restructure their code. Use OAuth in your API, follow the spec. We’re comfortable using OAuth libraries, and if your API works with it out of the box, then we can jump right into implemeting your API.</p>

<h1 id="8-api-documentation">8. API documentation</h1>
<p>APIs take hours to design and develop. You will be spending enormous amounts of effort to make your API as developer friendly as possible. You should be putting the same effort into your developer documentation. As the designer of a popular API you may feel like you’re spending a huge portion of your day telling developers to RTFM, and thats never going to disappear. But if you do it right, for every developer that gets lazy and skips the documentation, you’ll have 10 that were able to integrate your API without any problems.</p>

<h1 id="summary">Summary</h1>
<p>I didn’t mean to make GoodReads the API whipping boy here, we’ve all had to deal with API integration problems before, but with the growing prevalence of SAAS, I thought you should see some of the issues that developers are facing when using your API.</p>

<p><a href="http://www.quietthyme.com">QuietThyme</a>
GoodReads integration is just one of the many third-party services we support at <a href="http://www.quietthyme.com">QuietThyme</a>. We support the usual Facebook, Twitter, LinkedIn and Google authentication as well as allowing you to store you full library on your own private DropBox while letting us manage your Ebook Metadata and Cover art. Check us out at www.quietthyme.com.</p>


	  ]]></description>
	</item>


</channel>
</rss>
