<?xml version="1.0" encoding="UTF-8" ?>

<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
   
      <title>blog.thesparktree.com</title>
   
   <link>https://blog.thesparktree.com</link>
   <description>Devops posts & guides about interesting tech like Docker, Letsencrypt, Chef, Angular, Automation, API's or other topics that you should know about. </description>
   <language>en-uk</language>
   <managingEditor> Jason Kulatunga</managingEditor>
   <atom:link href="rss" rel="self" type="application/rss+xml" />
   
	<item>
	  <title>Go - Serverless Framework - Newrelic</title>
	  <link>/go-serverless-framework-newrelic</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2024-01-21T03:19:33-06:00</pubDate>
	  <guid>/go-serverless-framework-newrelic</guid>
	  <description><![CDATA[
	     <p>Because I seem to be a glutton for punishment, I decided to build an API for <a href="https://www.fastenhealth.com/">my startup Fasten Health</a> using Go + Serverless Framework + 
Newrelic. As expected this was difficult for a number of reasons:</p>

<ul>
  <li>Go is not a first class citizen in the Serverless Framework ecosystem. While it is supported, it is not as well documented as NodeJS.</li>
  <li>Newrelic’s AWS Lambda integration has gone through multiple iterations, and their documentation is not clear what is the “best” way to integrate.
    <ul>
      <li>Newrelic’s CloudWatch integration has been deprecated and replaced with a Lambda Layer.</li>
      <li>The Lambda layer integration <a href="https://github.com/newrelic/serverless-newrelic-lambda-layers/issues/334">requires code changes in Go, unlike the NodeJS, Python and other integrations</a></li>
      <li>The Lambda layer integration only works with the new <a href="https://aws.amazon.com/blogs/compute/migrating-aws-lambda-functions-from-the-go1-x-runtime-to-the-custom-runtime-on-amazon-linux-2/">Amazon Linux 2023 <code class="language-plaintext highlighter-rouge">provided</code> runtime</a> instead of the older but more commonly used <code class="language-plaintext highlighter-rouge">go1.x</code> runtime.</li>
    </ul>
  </li>
  <li>The Amazon Linux 2023 <code class="language-plaintext highlighter-rouge">provided</code> runtime has a requirement that the entrypoint binary is named <code class="language-plaintext highlighter-rouge">bootstrap</code>. This is difficult to do natively with the Serverless Framework, and requires a custom plugin]()</li>
  <li>There is no “agentless” integration for Newrelic. You must install the Newrelic agent in your Lambda function, and then configure your app/code to send data to Newrelic.</li>
</ul>

<p>Since there doesn’t seem to be much public documentation for how to get everything working correctly, I’ve documented my process below.</p>

<div class="github-widget" data-repo="AnalogJ/newrelic-serverless-go-playground"></div>

<h2 id="1-linking-aws--newrelic">1. Linking AWS &amp; Newrelic</h2>

<p>The Newrelic documentation for <a href="https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/account-linking/">linking your AWS account</a> is pretty thorough,
however the “Linking accounts manually” alternative method was completely broken for me.</p>

<p>While I was unhappy installing another tool on my dev machine, the <code class="language-plaintext highlighter-rouge">newrelic-lambda</code> cli tool worked perfectly.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newrelic-lambda integrations <span class="nb">install</span> <span class="nt">--nr-account-id</span> YOUR_NR_ACCOUNT_ID <span class="se">\</span>
    <span class="nt">--nr-api-key</span> YOUR_NEW_RELIC_USER_KEY
</code></pre></div></div>

<p>Here’s how you get the Account ID and User Key for use with the CLI:</p>

<ul>
  <li><a href="https://docs.newrelic.com/docs/accounts/install-new-relic/account-setup/account-id/">YOUR_NR_ACCOUNT_ID</a>
    <ul>
      <li>From one.newrelic.com, click the user menu, and then go to: Administration &gt; Access management &gt; Accounts to see account IDs.</li>
    </ul>
  </li>
  <li><a href="https://docs.newrelic.com/docs/apis/intro-apis/new-relic-api-keys/">YOUR_NEW_RELIC_USER_KEY</a>
    <ul>
      <li>Create and manage your API keys from the <a href="https://one.newrelic.com/launcher/api-keys-ui.api-keys-launcher">API keys UI page</a> so you can start observing your data right away</li>
      <li>NOTE: You must select a <code class="language-plaintext highlighter-rouge">USER</code> key, not an <code class="language-plaintext highlighter-rouge">INGEST - *</code> key, otherwise you’ll get an error when attemping to link your account.</li>
    </ul>
  </li>
</ul>

<p>Immediately after this step, you should be able to see your AWS account listed in the Newrelic UI. The <code class="language-plaintext highlighter-rouge">newrelic-lambda</code> cli tool will also 
create a <code class="language-plaintext highlighter-rouge">NEW_RELIC_LICENSE_KEY</code> secret in your AWS Secrets Manager, which is used by the Newrelic Lambda Layer.</p>

<blockquote>
  <p>NOTE: if all you care about is invocation and error metrics, you can stop here. The AWS Integration will allow you to see invocation and error metrics in Newrelic, but you won’t be able to see any custom metrics, logs or traces.
The following steps are required if you would like to see this additional telemetry in Newrelic.</p>
</blockquote>

<h2 id="2-serverless-framework---golang-plugin">2. Serverless Framework - Golang Plugin</h2>

<p>The first change we need to make to our Serverless Framework configuration is to add the <a href="https://github.com/mthenw/serverless-go-plugin">Serverless Framework Golang Plugin</a>.</p>

<p>This plugin allows us to build our Go binaries, and and is compatible with the Amazon Linux 2023 <code class="language-plaintext highlighter-rouge">provided</code> runtime which is required for the Newrelic Lambda Layer.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">plugins</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">serverless-go-plugin</span>
<span class="nn">...</span>

<span class="na">custom</span><span class="pi">:</span>
  <span class="na">go</span><span class="pi">:</span>
    <span class="na">baseDir</span><span class="pi">:</span> <span class="s">.</span>
    <span class="na">binDir</span><span class="pi">:</span> <span class="s">bin</span>
    <span class="na">cgo</span><span class="pi">:</span> <span class="m">0</span>
    <span class="c1"># compile command, make sure GOOS and GOARCH are set correctly</span>
    <span class="na">cmd</span><span class="pi">:</span> <span class="s">GOARCH=amd64 GOOS=linux go build -ldflags="-s -w"</span>
    <span class="c1"># the plugin compiles a function only if runtime is declared here (either on function or provider level)</span>
    <span class="na">supportedRuntimes</span><span class="pi">:</span> <span class="pi">[</span><span class="s2">"</span><span class="s">provided.al2"</span><span class="pi">]</span>
    <span class="c1"># builds and archive function with only single "bootstrap" binary, required for `provided.al2` and `provided` runtime</span>
    <span class="na">buildProvidedRuntimeAsBootstrap</span><span class="pi">:</span> <span class="kc">true</span>
</code></pre></div></div>

<h2 id="3-serverless-framework---newrelic-lambda-layer-plugin">3. Serverless Framework - Newrelic Lambda Layer Plugin</h2>

<p>Next, we need to add the <a href="https://github.com/newrelic/serverless-newrelic-lambda-layers">Serverless Framework Newrelic Lambda Layer Plugin</a></p>

<p>This plugin allows us to add the Newrelic Lambda Layer to our function, which contains a Newrelic agent that our Newrelic <code class="language-plaintext highlighter-rouge">go-agent</code> sdk will use send data to Newrelic.</p>

<p>We need to install the Serverless plugin, specify the <code class="language-plaintext highlighter-rouge">provider</code> runtime and then specify the configuration.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">accountId</code> - this is the <code class="language-plaintext highlighter-rouge">YOUR_NR_ACCOUNT_ID</code> value from Step 1</li>
  <li><code class="language-plaintext highlighter-rouge">apiKey</code> - this is the <code class="language-plaintext highlighter-rouge">YOUR_NEW_RELIC_USER_KEY</code> value from Step 1</li>
</ul>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">plugins</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">serverless-newrelic-lambda-layers</span>
<span class="nn">...</span>

<span class="na">provider</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">aws</span>
  <span class="na">runtime</span><span class="pi">:</span> <span class="s">provided.al2</span>

<span class="na">custom</span><span class="pi">:</span>
  <span class="na">newRelic</span><span class="pi">:</span>
    <span class="na">accountId</span><span class="pi">:</span> <span class="s">YOUR_NR_ACCOUNT_ID</span>
    <span class="na">apiKey</span><span class="pi">:</span> <span class="s">YOUR_NEW_RELIC_USER_KEY</span>
    <span class="na">debug</span><span class="pi">:</span> <span class="kc">true</span>

</code></pre></div></div>

<h2 id="4-serverless-framework---iam-role--iam-roles-per-function">4. Serverless Framework - IAM Role &amp; IAM Roles Per Function</h2>

<p>While the steps above are documented in various locations on the internet, it wasn’t clear to me that the Newrelic Lambda Layer seems to require a AWS Secret Manager integration
to retrieve the Newrelic License Key. Initially, I tried manually specifying the key using <code class="language-plaintext highlighter-rouge">newrelic.ConfigLicense(os.Getenv("NEW_RELIC_LICENSE_KEY"))</code> to configure the Newrelic <code class="language-plaintext highlighter-rouge">go-agent</code> sdk, but that didn’t work.
The solution was to specify the an IAM Role for the Serverless function, giving it permissions to AWS Secret Manager to pull the <code class="language-plaintext highlighter-rouge">NEW_RELIC_LICENSE_KEY</code> secret.</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">plugins</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">serverless-iam-roles-per-function</span>

<span class="nn">...</span>

<span class="na">functions</span><span class="pi">:</span>
  <span class="na">healthcheck</span><span class="pi">:</span>
    <span class="na">handler</span><span class="pi">:</span> <span class="s">cmd/health/health.go</span>
    <span class="na">iamRoleStatements</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">Effect</span><span class="pi">:</span> <span class="s2">"</span><span class="s">Allow"</span>
        <span class="na">Action</span><span class="pi">:</span>
          <span class="pi">-</span> <span class="s2">"</span><span class="s">secretsmanager:GetSecretValue"</span>
        <span class="c1"># This is the secret that was created by the newrelic-lambda cli tool. </span>
        <span class="c1"># To find it, open the AWS Console, and go to: Secrets Manager &gt; Secrets &gt; Find "NEW_RELIC_LICENSE_KEY", then copy the ARN</span>
        <span class="na">Resource</span><span class="pi">:</span> <span class="s2">"</span><span class="s">arn:aws:secretsmanager:us-east-1:1234567890:secret:NEW_RELIC_LICENSE_KEY-XXXXX"</span>
    <span class="na">events</span><span class="pi">:</span>
      <span class="pi">-</span> <span class="na">httpApi</span><span class="pi">:</span>
          <span class="na">path</span><span class="pi">:</span> <span class="s">/health</span>
          <span class="na">method</span><span class="pi">:</span> <span class="s">get</span>

</code></pre></div></div>

<h2 id="5-application-code---metrics">5. Application Code - Metrics</h2>

<p>Finally, we need to modify our Serverless function code to use the <code class="language-plaintext highlighter-rouge">go-agent</code> sdk.</p>

<p>Notice how the <code class="language-plaintext highlighter-rouge">newrelic.NewApplication()</code> call has minimal configuration options specified (compared to the <a href="https://github.com/newrelic/go-agent/blob/master/v3/integrations/nrawssdk-v2/example/main.go">Raw AWS SDK Example</a>)</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
	<span class="s">"context"</span>
	<span class="s">"fmt"</span>

	<span class="s">"github.com/newrelic/go-agent/v3/integrations/nrlambda"</span>
	<span class="n">newrelic</span> <span class="s">"github.com/newrelic/go-agent/v3/newrelic"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">handler</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">{</span>
	<span class="c">// The nrlambda handler instrumentation will add the transaction to the</span>
	<span class="c">// context.  Access it using newrelic.FromContext to add additional</span>
	<span class="c">// instrumentation.</span>
	<span class="n">txn</span> <span class="o">:=</span> <span class="n">newrelic</span><span class="o">.</span><span class="n">FromContext</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span>
	<span class="n">txn</span><span class="o">.</span><span class="n">AddAttribute</span><span class="p">(</span><span class="s">"userLevel"</span><span class="p">,</span> <span class="s">"gold"</span><span class="p">)</span>
	<span class="n">txn</span><span class="o">.</span><span class="n">Application</span><span class="p">()</span><span class="o">.</span><span class="n">RecordCustomEvent</span><span class="p">(</span><span class="s">"MyEvent"</span><span class="p">,</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="k">interface</span><span class="p">{}{</span>
		<span class="s">"zip"</span><span class="o">:</span> <span class="s">"zap"</span><span class="p">,</span>
	<span class="p">})</span>

	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="c">// Pass nrlambda.ConfigOption() into newrelic.NewApplication to set</span>
	<span class="c">// Lambda specific configuration settings including</span>
	<span class="c">// Config.ServerlessMode.Enabled.</span>
	<span class="n">app</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">newrelic</span><span class="o">.</span><span class="n">NewApplication</span><span class="p">(</span><span class="n">nrlambda</span><span class="o">.</span><span class="n">ConfigOption</span><span class="p">())</span>
	<span class="k">if</span> <span class="no">nil</span> <span class="o">!=</span> <span class="n">err</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s">"error creating app (invalid config):"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c">// nrlambda.Start should be used in place of lambda.Start.</span>
	<span class="c">// nrlambda.StartHandler should be used in place of lambda.StartHandler.</span>
	<span class="n">nrlambda</span><span class="o">.</span><span class="n">Start</span><span class="p">(</span><span class="n">handler</span><span class="p">,</span> <span class="n">app</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://blog.thesparktree.com/assets/images/newrelic/metrics.png" alt="metrics" /></p>

<h2 id="6-application-code---logs">6. Application Code - Logs</h2>

<p>If you had deployed the Serverless function defined in Step 5 as-is, you would see your metrics, however you would not see any logs in Newrelic.
This is because you’re missing the last bit of configuration to enable the Newrelic Lambda Extension to send logs to Newrelic.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>
<span class="k">import</span> <span class="p">(</span>
  <span class="s">"context"</span>
  <span class="s">"fmt"</span>

  <span class="s">"github.com/newrelic/go-agent/v3/integrations/nrlambda"</span>
  <span class="n">newrelic</span> <span class="s">"github.com/newrelic/go-agent/v3/newrelic"</span>
<span class="p">)</span>
<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="o">...</span>
	
	
	<span class="n">app</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">newrelic</span><span class="o">.</span><span class="n">NewApplication</span><span class="p">(</span>
        <span class="n">nrlambda</span><span class="o">.</span><span class="n">ConfigOption</span><span class="p">(),</span>
        
		<span class="c">// This is the configuration that enables the Newrelic Lambda Extension to send logs to Newrelic</span>
        <span class="n">newrelic</span><span class="o">.</span><span class="n">ConfigAppLogForwardingEnabled</span><span class="p">(</span><span class="no">true</span><span class="p">),</span>
		<span class="k">func</span><span class="p">(</span><span class="n">config</span> <span class="o">*</span><span class="n">newrelic</span><span class="o">.</span><span class="n">Config</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">logrus</span><span class="o">.</span><span class="n">SetLevel</span><span class="p">(</span><span class="n">logrus</span><span class="o">.</span><span class="n">DebugLevel</span><span class="p">)</span>
			<span class="n">config</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">nrlogrus</span><span class="o">.</span><span class="n">StandardLogger</span><span class="p">()</span>
		<span class="p">},</span>
	<span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://blog.thesparktree.com/assets/images/newrelic/logs.png" alt="metrics" /></p>

<h1 id="fin">Fin</h1>

<p>That’s it! Trigger a deployment, visit your Serverless function &amp; you should now be able to see your Serverless function metrics and logs in Newrelic.</p>

<p>If you encounter any issues, refer to my <a href="https://github.com/AnalogJ/newrelic-serverless-go-playground">GitHub repository</a> for a working example. Happy coding!</p>

<div class="github-widget" data-repo="AnalogJ/newrelic-serverless-go-playground"></div>

<h1 id="references">References</h1>
<ul>
  <li><a href="https://github.com/newrelic/newrelic-lambda-extension/blob/main/examples/sam/go/main.go">Newrelic Lambda Extension Example</a></li>
  <li><a href="https://github.com/newrelic/go-agent/blob/master/v3/integrations/nrlambda/example/main.go">Newrelic Go-Agent SDK Lamdba Example</a></li>
  <li><a href="https://github.com/newrelic/go-agent/blob/master/GUIDE.md#full-list-of-config-options-and-application-settings">Newrelic Go-Agent SDK Full Options</a></li>
  <li><a href="https://github.com/newrelic/docs-website/blob/develop/src/content/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/compatibility-requirements-aws-lambda-monitoring.mdx">Newrelic Lambda Layer Supported Runtimes</a></li>
  <li><a href="https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/account-linking/#troubleshooting">Newrelic Troubleshooting Guide for Lambdas</a></li>
  <li><a href="https://forum.newrelic.com/s/hubtopic/aAX8W0000008eWv/lambda-troubleshooting-framework-troubleshooting-lambda-part-1">Newrelic Troubleshooting Guide for Lambdas - Forum Post - Part 1</a></li>
  <li><a href="https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda-legacy/">Newrelic Legacy manual instrumentation for Lambda monitoring</a></li>
  <li><a href="https://github.com/newrelic/serverless-newrelic-lambda-layers">Newrelic Lambda Layer Plugin for Serverless Framework</a></li>
  <li><a href="https://github.com/mthenw/serverless-go-plugin">Serverless Framework Go Plugin</a></li>
</ul>

	  ]]></description>
	</item>

	<item>
	  <title>CapsuleCD v2 Released</title>
	  <link>/capsulecd-v2-released</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2017-08-06T04:19:33-05:00</pubDate>
	  <guid>/capsulecd-v2-released</guid>
	  <description><![CDATA[
	     <p><a href="https://github.com/AnalogJ/capsulecd">CapsuleCD</a> is made up of a series of scripts/commands that
make it easy for you to package and release a new version of your library artifact (Ruby gem, Npm package, Chef cookbook.. ) while still following best practices:</p>

<ul>
  <li>bumping <code class="language-plaintext highlighter-rouge">semvar</code> tags</li>
  <li>regenerating any <code class="language-plaintext highlighter-rouge">*.lock</code> files</li>
  <li>validates all dependencies exist and are free of vulnerabilities</li>
  <li>runs unit tests &amp; linters</li>
  <li>uploads versioned artifact to community hosting service (rubygems/supermarket/pypi/etc)</li>
  <li>creating a new git tag</li>
  <li>pushing changes back to source control &amp; creating a release</li>
  <li>and others..</li>
</ul>

<p>While <code class="language-plaintext highlighter-rouge">CapsuleCD</code> <strong>was</strong> a series of scripts, with the release of <strong>v2</strong> that’s no longer the case.</p>

<p><code class="language-plaintext highlighter-rouge">CapsuleCD</code> has been re-written, and is now available as a <a href="https://github.com/AnalogJ/capsulecd/releases">static binary</a>
on <a href="https://github.com/AnalogJ/capsulecd/releases/download/v2.0.10/capsulecd-darwin-amd64"><code class="language-plaintext highlighter-rouge">macOS</code></a> and
<a href="https://github.com/AnalogJ/capsulecd/releases/download/v2.0.10/capsulecd-linux-amd64"><code class="language-plaintext highlighter-rouge">Linux</code></a>
(<code class="language-plaintext highlighter-rouge">Windows</code> and <code class="language-plaintext highlighter-rouge">NuGet</code> support is hopefully coming soon)</p>

<p>You no longer need to worry that the version of Ruby used by your library &amp; <code class="language-plaintext highlighter-rouge">gemspec</code> is different than the
version required by <code class="language-plaintext highlighter-rouge">CapsuleCD</code>. If you maintain any Python or NodeJS libraries, this also means that a Ruby
runtime for just for CapsuleCD is unnecessary. The <code class="language-plaintext highlighter-rouge">CapsuleCD</code> <a href="https://hub.docker.com/r/analogj/capsulecd/tags/">Docker</a>
images for other languages are much slimmer, and based off the standard community images with <a href="https://github.com/AnalogJ/capsulecd-docker">minimal changes</a>.</p>

<p>Releasing a new version of your Ruby library hasn’t changed, it’s as easy as downloading the <a href="https://github.com/AnalogJ/capsulecd/releases">binary</a> and running:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CAPSULE_SCM_GITHUB_ACCESS_TOKEN=123456789ABCDEF \
CAPSULE_SCM_REPO_FULL_NAME=AnalogJ/gem_analogj_test \
CAPSULE_SCM_PULL_REQUEST=4 \
CAPSULE_RUBYGEMS_API_KEY=ASDF12345F \
capsulecd start --scm github --package_type ruby
</code></pre></div></div>

<p>Click below to watch a screencast of <code class="language-plaintext highlighter-rouge">CapuleCD</code> in action:</p>

<p align="center">
<a href="https://analogj.github.io/capsulecd">
  <img alt="CapsuleCD screencast" width="800" src="https://cdn.rawgit.com/AnalogJ/capsulecd/v2.0.10/capsulecd-screencast.png" />
  </a>
</p>

<div class="github-widget" data-repo="AnalogJ/capsulecd"></div>


	  ]]></description>
	</item>

	<item>
	  <title>15 Lessons in Golang</title>
	  <link>/15-lessons-in-golang</link>
	  <author>Jason Kulatunga</author>
	  <pubDate>2017-07-31T04:19:33-05:00</pubDate>
	  <guid>/15-lessons-in-golang</guid>
	  <description><![CDATA[
	     <p>Like many developers, I heard a lot of buzz about Golang (or is it Go, I’m still not sure).
In case you’re not familiar with it, it’s an open source language developed by Google.
It mostly caught my interest due to the fact that it’s pitched as a statically typed, compiled modern language.</p>

<p>For a long time that was the extent of my Golang knowledge. I knew I wanted to take a closer look at
it at some point, but I had other priorities. About 4 months ago, I realized the Golang could be the
solution to one of the problems I was facing with <a href="https://github.com/AnalogJ/capsulecd">CapsuleCD</a>, my application for generically automating
package releases for any language (npm, cookbooks, gems, pip, jars, etc).</p>

<div class="github-widget" data-repo="AnalogJ/capsulecd"></div>

<p>The problem was that <a href="https://github.com/AnalogJ/capsulecd">CapsuleCD</a> was a executable distributed in a Ruby gem, which meant that anyone
who wanted to use <code class="language-plaintext highlighter-rouge">CapsuleCD</code> needed to have a Ruby interpreter installed on their build machine, even
if all they were just trying to do was package a Python library. This made my Docker containers bloated,
and more complicated to develop. Wouldn’t it be nice to just have single binary I could download into the
container? And so the migration to Golang began, if only in my head at that point.</p>

<p>Over the next couple months, I kept going back to that idea, and a couple weeks ago, I finally sat down and
started porting my ~3000 line Ruby application to Golang. While I could have just bought a book like Golang
for Dummies, I decided to just jump into the coding, and just read blog posts and stack overflow when I got stuck.</p>

<p>I can already hear some of you cringing. To be honest, while I was having a lot of fun, my initial development
was pretty slow. I was trying to write an application in a new language, without knowing any of the conventions.
The thing is, I loved it. Those “Ah-Ha!” moments and getting things compiling again after a huge refactor
were an incredible motivator.</p>

<p>Here’s a bunch of the unexpected/unconventional things I learned while porting my app to Golang.</p>

<blockquote>
  <p>Please note, these are things that I didn’t <strong>expect</strong> when I started writing Golang code with a
background in popular typed and dynamically typed languages, (C++, C#, Java, Ruby, Python and NodeJS).
These are not necessarily criticisms of Golang. I was able to go from 0 -&gt; working release of my software
in a completely new language in 2 weeks. That’s pretty awesome if you ask me.</p>
</blockquote>

<h1 id="before-your-first-line">Before your first line.</h1>

<h2 id="package-layout">Package Layout</h2>
<p>While not required for a compiled language, I was still unprepared for the fact that there doesn’t seem to be a <strong>Standard™</strong> folder structure for a Golang library, like there is for Ruby, Chef &amp; Node. There seem to be a couple of popular community structures, and I found myself liking <a href="https://peter.bourgon.org/go-best-practices-2016/#repository-structure">Peter Bourgon’s recommendations</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>github.com/peterbourgon/foo/
  circle.yml
  Dockerfile
  cmd/
    foosrv/
      main.go
    foocli/
      main.go
  pkg/
    fs/
      fs.go
      fs_test.go
      mock.go
      mock_test.go
    merge/
      merge.go
      merge_test.go
    api/
      api.go
      api_test.go
</code></pre></div></div>

<h2 id="circular-dependencies">!Circular Dependencies</h2>
<p>Package layout becomes even more important when you find out that Golang does’t support circular
dependencies between packages. If A imports B, and B imports A, Golang will give up and complain.
I actually kinda like it, as it forced me to think a bit more about my application’s domain model.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import cycle not allowed
package github.com/AnalogJ/dep/a
  imports github.com/AnalogJ/dep/b
  imports github.com/AnalogJ/dep/a
</code></pre></div></div>

<h2 id="dependency-management">Dependency management</h2>
<p><code class="language-plaintext highlighter-rouge">npm</code>, <code class="language-plaintext highlighter-rouge">pypi</code>, <code class="language-plaintext highlighter-rouge">bundler</code>. Each of these package managers are synonymous with their language. However Golang
doesn’t have an official package manger (<a href="https://github.com/golang/dep">yet</a>). In the meantime the community
has come up with a <a href="https://github.com/Masterminds/glide">couple</a> <a href="https://github.com/FiloSottile/gvt">of</a>
<a href="https://github.com/kardianos/govendor">good</a> <a href="https://github.com/FiloSottile/gvt">alternatives</a>. The problem
is that they are all really good, and it can be a bit daunting to pick one. I ended up choosing <a href="https://github.com/Masterminds/glide">Glide</a>,
because it has a similar feel to <code class="language-plaintext highlighter-rouge">bundler</code> and <code class="language-plaintext highlighter-rouge">npm</code>.</p>

<h2 id="documentation">Documentation</h2>
<p>This is actually one of the best things about Golang. <code class="language-plaintext highlighter-rouge">go docs</code> and the <code class="language-plaintext highlighter-rouge">godoc.org</code> site are awesome
and standardize the documentation for any library you might use. This is a nice step up from the NodeJS
community where all package documentation is custom and self hosted.</p>

<h2 id="goroot-gopath">GOROOT, GOPATH</h2>
<p>Golang imports are done in a kind of weird way. Unlike most other languages, Golang basically requires
that your source live in pre-configured folder(s). I’m not going to delve into the details, but you should
know that it takes a bit of setup &amp; getting used to. Dmitri Shuralyov’s <a href="https://dmitri.shuralyov.com/blog/18">How I use GOPATH with multiple
workspaces</a> is a great resource.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GOPATH=/landing/workspace/path:/personal/workspace/path:/corporate/workspace/path
</code></pre></div></div>

<h1 id="scratching-that-itch">Scratching that Itch.</h1>

<h2 id="pseudo-class-struct-inheritance">Pseudo <del>Class</del> Struct Inheritance</h2>
<p>The Golang developers did some interesting things when designing the inheritance model. Instead of using
one of the more conventional inheritance models of typed languages like multiple-inheritance or classical
inheritance, Golang follows a multiple composition pattern similar to Ruby.
<a href="https://github.com/luciotato/golang-notes/blob/master/OOP.md#method-shadowing">Method-Shadowing</a> can
cause some unexpected results if not understood completely.</p>

<h2 id="duck-typed-interfaces">Duck-Typed Interfaces</h2>
<p>This is another cool unexpected feature of Golang. Interfaces are <a href="https://en.wikipedia.org/wiki/Duck_typing">duck-typed</a>,
something I’ve only seen in dynamically typed languages. This duck-typing works hand-in-hand with <code class="language-plaintext highlighter-rouge">struct</code>
composition.</p>

<h2 id="structs-have-fields-interfaces-dont">Structs have fields, Interfaces don’t</h2>
<p>Unfortunately <code class="language-plaintext highlighter-rouge">structs</code> can’t have the same <em>API</em> as <code class="language-plaintext highlighter-rouge">interfaces</code>, as the latter cannot define fields. This
is not a huge issue, as one can just define a getter and a setter method on the interface, but it was a bit
confusing. I’m sure theres a good technical/CS theory answer for why this is, but yeah.</p>

<h2 id="publicprivate-naming">Public/Private naming</h2>
<p>Golang took Python’s <code class="language-plaintext highlighter-rouge">public</code> and <code class="language-plaintext highlighter-rouge">private</code> method naming scheme one level further. When I initially found
out that functions, methods and struct names starting with an uppercase character are public and lowercase
are private, I wasn’t sure how to feel about it. But honestly, after working with Golang for 2 weeks, I
really like this convention.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type PublicStructName struct {}
type privateStructName struct {}
</code></pre></div></div>

<h2 id="defer">defer</h2>
<p>Another surprisingly useful feature Golang. I’m sure it’s a result of Golang’s parallel processing and
error model, but <code class="language-plaintext highlighter-rouge">defer</code>’s make it really easy to keep your cleanup close to the originating code. Mentally
I treat it like an alternative to a <code class="language-plaintext highlighter-rouge">finally</code> method in the <code class="language-plaintext highlighter-rouge">try-catch-finally</code> pattern or the <code class="language-plaintext highlighter-rouge">using</code>
block in <code class="language-plaintext highlighter-rouge">C#</code>/<code class="language-plaintext highlighter-rouge">Java</code> but I’m sure there are more creative uses for it.</p>

<h2 id="go-fmt-is-awesome"><code class="language-plaintext highlighter-rouge">go fmt</code> is awesome</h2>
<p>You’ll never have the “tabs vs spaces” debate with a Golang developer. There is a standardized Golang
style and <code class="language-plaintext highlighter-rouge">go fmt</code> can reformat your code to comply with it. It’s a neat tool, and reading its source
introduced me to the powerful <a href="https://golang.org/pkg/go/parser/"><code class="language-plaintext highlighter-rouge">parser</code></a> and <a href="https://golang.org/pkg/go/ast/"><code class="language-plaintext highlighter-rouge">ast</code></a> libraries.</p>

<h2 id="goarch-goos-cgo--cross-compiling">GOARCH, GOOS, CGO &amp; Cross Compiling</h2>
<p>My goal of creating a single standalone <code class="language-plaintext highlighter-rouge">CapsuleCD</code> binary is the entire reason I started my port
to Golang. However it quickly became apparent that simple static binaries aren’t an intrinsic feature
of Golang (which should have been obvious). If your code is all written in vanilla Golang, and the code
of all your dependencies (and their dependencies), then you can <a href="http://golangcookbook.com/chapters/running/cross-compiling/">build static binaries</a>
to your heart’s content using <code class="language-plaintext highlighter-rouge">GOOS</code> and <code class="language-plaintext highlighter-rouge">GOARCH</code>. However if you’re unlucky like I was, and you have
a dependency that calls <code class="language-plaintext highlighter-rouge">C</code> code under the hood (by importing a <code class="language-plaintext highlighter-rouge">C pseudo-package</code>) then you’re in for
a world of pain. Don’t get me wrong, creating a dynamically linked binary is still super easy. But to
generate a static binary, with no external dependencies, means you need to ensure that all your
<code class="language-plaintext highlighter-rouge">C</code> dependencies (and their dependencies) are all statically linked too. Like I said, obvious.
<code class="language-plaintext highlighter-rouge">C pseudo-packages</code> are compiled via <code class="language-plaintext highlighter-rouge">CGO</code>, and you’ll need to look at the documentation to find all
the compiler flags necessary to help <code class="language-plaintext highlighter-rouge">CGO</code> locate your static libraries. A table of all supported GOOS
and GOARCH pairs is located in the <a href="https://golang.org/doc/install/source#environment">Golang docs</a></p>

<h1 id="how-do-i-test-this">How do I test this?</h1>

<h2 id="hidden-in-plain-sight">Hidden in plain sight</h2>
<p>Test files are suffixed with <code class="language-plaintext highlighter-rouge">_test.go</code> and should be located side-by-side with the code they test,
rather than relegated to a special testing folder. Its nice, even though it feels a bit cluttered at first.</p>

<p>Test data goes in a special <code class="language-plaintext highlighter-rouge">testdata</code> folder. Both the <code class="language-plaintext highlighter-rouge">testdata</code> folder and <code class="language-plaintext highlighter-rouge">_test.go</code> files are completely
ignored by the compiler during <code class="language-plaintext highlighter-rouge">go build</code>.</p>

<h2 id="go-list-and-vendor-folder"><code class="language-plaintext highlighter-rouge">go list</code> and <code class="language-plaintext highlighter-rouge">vendor</code> folder</h2>
<p>So, dependency management is pretty new to the Golang language, and not all tools understand the special
<code class="language-plaintext highlighter-rouge">vendor</code> folder. As such, when you run <code class="language-plaintext highlighter-rouge">go test</code>, by default you’ll find it running the tests of all your
dependencies. Use <code class="language-plaintext highlighter-rouge">go list | grep -v /vendor</code> to get Golang to ignore the vendor folder.</p>

<p><code class="language-plaintext highlighter-rouge">go fmt $(go list ./... | grep -v /vendor/)</code></p>

<h2 id="if-err--nil"><code class="language-plaintext highlighter-rouge">if err != nil</code></h2>
<p>I’m a stickler for code coverage. I try to keep my open source projects above 80% coverage, but I’m having
a hard time doing that with Golang. Those of you already familiar with Golang will probably just point out that
Golang is one of the easiest languages to get <a href="https://blog.golang.org/cover">good coverage in</a>. Rather
than creating a seperate execution path for errors (<code class="language-plaintext highlighter-rouge">try-catch-finally</code>) Golang treats all errors as standard objects.
Golang convention states that functions which can produce errors should return them as it’s last <code class="language-plaintext highlighter-rouge">return</code> argument.</p>

<p>It’s a pretty interesting model, which reminds me a bit of <code class="language-plaintext highlighter-rouge">Node</code>’s built-in functions. However, just like <code class="language-plaintext highlighter-rouge">Node</code>, it can
be difficult to write unit tests that produce errors in built-in functionality. This becomes even more annoying when you follow
a coding pattern where you bubble-up errors, and then handle them at a higher level. When doing this, you’ll write alot of
code the looks like the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>data, err := myfunction(...)
if(err != nil){
	return err
}

data2, err2 := myfunction2(...)
if(err2 != nil){
	return err
}

</code></pre></div></div>

<p>This starts to clutter up your code pretty quick. At this point some of you may be thinking that <code class="language-plaintext highlighter-rouge">interface</code>s and <code class="language-plaintext highlighter-rouge">mock</code>s
would solve these problems. While that’s true in some cases, I don’t think it makes sense to write massive <code class="language-plaintext highlighter-rouge">interface</code>s for
built-in libraries like <code class="language-plaintext highlighter-rouge">os</code> and <code class="language-plaintext highlighter-rouge">ioutil</code>, or pass those libraries in as arguments, just so that we can artifically generate
errors for <code class="language-plaintext highlighter-rouge">ioutil.WriteFile</code> and <code class="language-plaintext highlighter-rouge">os.MkdirAll</code>.</p>

<p>I’m that this is definitely a shortcoming in my mental-model, but I’ve read a ton of documentation and blog posts on how
unit tests and code coverage should be done in Golang, and I still haven’t found a pattern that makes sense without
seeming to require a dependency injection engine of some sort, something that Golang seems to actively dislike as too cumbersome.</p>

<h1 id="conclusion">Conclusion</h1>

<p>I’d love to hear your thoughts. I’ve only been working with Golang for a few weeks, but it’s been an incredibly educational
and enjoyable experience. I was able to go from no experience to building a real, working application in Golang in very
little time, not just toy examples from some book. I know that I’m no expert in Golang yet, and that there are still  theory gaps
in my understanding of Golang, but I feel like they are much further apart than I expected when I went down this <code class="language-plaintext highlighter-rouge">self-taught without books</code> path.</p>

<p>Golang worked exactly as I thought it would, giving me <a href="https://github.com/AnalogJ/capsulecd/releases">binaries</a> that I can easily download
onto slim Docker containers, without requiring a Ruby interpreter. If you maintain executables in other languages, I would
definitely recommend you consider giving Golang a try.</p>

	  ]]></description>
	</item>


</channel>
</rss>
